---
title: MySQL 之索引设计
date: 2020-07-10 14:23:03
tags: MySQL
categories: MySQL
---

本文讲解索引设计的一般原则。



## 原则一

首先我们在针对业务需求建立一张表的结构之后，就知道这个表有哪些字段，每个字段是什么类型的，会包含哪些数据。设计好表结构之后，就是要设计表的索引。设计索引的时候，我们要考虑第一点，就是未来我们对表进行查询的时候，大概会如何来进行查询



可能有人会说，你要我刚设计完表结构就知道未来会怎么查询表，我怎么知道？没关系，其实我们完全可以在表结构设计完毕之后，不用先急着设计索引，因为此时你根本不知道要怎么查询表。接着我们进入开发环节，根据业务把你的 Java 代码写好。当你把系统开发差不多了，此时就可以考虑如何建立索引了，因为你系统里的 SQL 语句也差不多写好了



这个时候，第一个索引设计原则就来了，针对你的 SQL 语句里的 where 条件、order by 条件以及 group by 条件去设计索引。也就是说，你的 where 条件要根据哪些字段来筛选数据？order by 要根据哪些字段来排序？group by 要根据哪些字段来分组聚合？



此时你就可以设计一个或者两三个联合索引，每一个联合索引都尽量去包含上你的 where、order by、group by 里的字段，接着你就要仔细审查每个 SQL 语句，是不是每个 where、group by、order by 后面跟的字段顺序，都是某个联合索引的最左侧字段开始的部分字段



比如你有一个联合索引是 `INDEX(a, b, c)`，此时有三个 SQL，包含了 `where a = ? and b = ?` `order by a, b` `group by a` 这些部分，那么此时 where、order by、group by 后续跟的字段都是联合索引的最左侧开始的部分字段，这就可以了，说明你的 SQL 都会用上你的索引



## 原则二

原则一说了你设计的索引是让你的各个 where、order by 和 group by 后面跟的字段都是联合索引的最左侧开始的部分字段，这样他们能用上索引。但是在设计索引的时候还得考虑其它一些问题。首先一个就是字段基数问题。例如，有一个字段它一共在 10 万行数据里有 10 万个值，但是这个值，不是 0 就是 1。那么它的基数就是 2，因为这个字段的值就两选择：0 和 1



假设针对上面说的这种字段建立索引的话，那就还不如全表扫描，因为你的索引树里仅仅包含了 0 和 1 两种值，根本没法进行快速的二分查找，也就没有太大的意义了。所以这种时候，选用这种基数很低的字段放索引里意义就不大



**一般建立索引，尽量使用那些基数比较大的字段，就是值比较多的字段，才能发挥出 B+ 树快速二分查找的优势**



另外，你尽量是对那些**字段的类型比较小的列来设计索引**。比如 tinyint 之类的，因为它的字段类型比较小，说明这个字段本身的值占用磁盘空间小，此时你在搜索的时候性能也会比较好



当然，这个所谓的字段类型小一点的列，也不是绝对的。很多时候你就是要针对 `varchar(255)` 这种字段建立索引，哪怕多占用一些磁盘空间，那你也得去设计这样的索引。比较关键的其实还是尽量别把基数太低的字段包含在索引里



如果你真的有那种 `varchar(255)` 的字段，可能里面的值太大了，你觉得放索引树里太占内存空间，此时完全可以换一种策略，也就是仅仅针对这个 `varchar(255)` 字段的前 20 个字符建立索引，即，对这个字段里的每个值的前 20 个字符放在索引树里而已



此时你建立出来的索引其实类似于 `KEY my_index(name(20), age, course)` 这样的一个形式。假设 name 是 varchar(255) 类型的，但是在索引树里你对 name 的值仅仅提取前 20 个字符而已



此时你在 where 条件里搜索的时候，如果是根据 name 字段来搜索，那么此时就会先到索引树里根据 name 字段的前 20 个字符去搜索，定位到之后前 20 个字符的前缀匹配的部分数据之后，再回到聚簇索引提取出来完整的 name 字段进行比对就可以了



但是如果你要是 order by name，那么此时你的 name 因为在索引树里仅仅包含了前 20 个字符，所以这个排序是没法用上索引的。group by 也是同理的。这里要对前缀索引有一个了解



## 原则三

接着，你已经设计好了索引，然后在 SQL 里这么写：where function(a) = xx，你给你的索引里的字段 a 套了一个函数，此时这个索引就会失效。所以尽量不要让你的查询语句里的字段搞什么函数，或者是搞个计算



接着你系统跑起来了，有数据插入也有查询的情况，其实查询基本能走索引一般问题都不会太大的。但是插入就有点讲究了，因为你插入数据的时候，它肯定会更新索引树



你插入数据肯定会有主键吧，有主键就会更新聚簇索引树，你插入一条数据也会包含索引里各个字段的值，那你的联合索引的 B+ 树也要更新。即，你不停地增删改数据，就会不停地更新你的索引树。所以因为你插入的数据值可能根本不是根据顺序来的，很可能会导致索引树里的某个页就会自动分裂，这个页分裂的过程就会很耗费时间。



**因此一般设计索引的时候别太多，建立两三个联合索引就应该覆盖你这个表的全部查询了**。否则索引太多必然会导致你增删改数据的性能很差，因为要更新多个索引树



**另外很关键的一点，建议主键一定是自增的，别用 UUID 之类的**。因为主键自增，那么起码你的聚簇索引不会频繁地分裂，主键值都是有序的，就会自然地新增一个页而已。但是如果你用的是 UUID，那么也会导致聚簇索引频繁的页分裂。











