---
title: MySQL 锁
date: 2020-03-26 11:47:34
tags: MySQL
categories: MySQL
---

MySQL 的锁类型，一般就是表锁、行锁和页锁。



## MyIsam

一般 MyIsam 会加表锁。就是在 MyIsam 引擎下，执行查询的时候，会默认加个表共享锁，也就是表读锁，这个时候别人只能来查，不能写数据。当 MyIsam 写的时候，也会加个表独占锁，也就是写表锁，别人不能读也不能写。



## InnoDB

InnoDB 引擎一般用行锁，但是也有表锁。



InnoDB 的行锁有共享锁（S）和排它锁（X）。共享锁就是，多个事务可以加共享读锁读同一行数据，但是别的事务不能写这行数据；排它锁，就是一个事务只能写这行数据，别的事务只能读，不能写。



InnoDB 的表锁，分成意向共享锁，就是说加共享行锁的时候，必须先加这个共享表锁；还有一个意向排他锁，就是说，给某行加排他锁的时候，必须先给表加排他锁。这个表锁，是 InnoDB 引擎自动加的，不用你自己去加。



对于 `insert`、`update`、`delete`，InnoDB 会自动给那一行加行级排他锁。而对于 `select`，InnoDB 啥锁都不加，因为 InnoDB 默认实现了可重复读，也就是 mvcc 机制，所以多个事务随便读一个数据，一般不会有冲突，大家就读自己那个快读照就可以了，不涉及到什么锁的问题。



但是 InnoDB 从来不会自己主动加这个共享锁的，除非你用下面的语句自己手动加个锁：

- 手动加共享锁：`SELECT * FROM table WHERE id = 1 LOCK IN SHARE MODE`，那你就给那一行加了个共享锁，其他事务就不能来修改这行数据了。

- 手动加排他锁：`SELECT * FROM tabel WHERE id = 1 FOR UPDATE`，那你就给那一行加了个排他锁，意思是你准备修改，别的事务就不能修改了。别的事务会 hang 住。这个要慎用，一般我们线上系统不用这个，容易搞出问题。



所以，MySQL 的默认数据库的锁机制，就是：对一行数据，如果有人在修改，会加个排他锁，然后你不能修改，只能等着获取这把锁，但是这个时候你可以随便  `select`，就是查询你的事务开始之前那行数据的某个版本而已。然后你修改某行数据，会同时拿这个表的排他锁，但是，如果不同的事务修改不同的行，会拿不同行的行级排他锁，但是大家都会拿一个表的排他锁。实际上，InnoDB 的表级排他锁可以随便拿，这个是没有冲突的。



这就是 MySQL InnoDB 存储引擎默认的锁模式。相当于就是一行数据，同一个时刻只能一个人在修改，但是别人修改，你可以随便读，读的都是读某个版本的，走 mvcc 机制。



## 悲观锁和乐观锁

MySQL 里的悲观锁是走 `SELECT * FROM table WHERE id = 1 FOR UPDATE`。意思是我很悲观，我担心自己拿不到这把锁，我必须先锁死，然后就我一个人可以搞事情，别人都不行，不能加共享锁，也不能加排他锁。



乐观锁，就是我觉得应该没啥问题，我修改的时候感觉差不多可以获取到锁，不需要提前搞一把锁，我就先查出来某个数据，`SELECT id, name, version FROM table WHERE id = 1`，接着再执行各种业务逻辑之后再修改， `UPDATE table SET name = '新值', version = version + 1 WEHRE id = 1 AND version = 1`。就是说每次修改，比较一下这条数据的当前版本号跟我之前查出来的版本号是不是不一样。如果是一样的就修改然后把版本号加 1，否则就不会更新任何一行数据，此时就重新查询后再次更新。



一般悲观锁什么时候用？比如你查出来了一条数据，要在内存中修改后再更新到数据库中去，但是如果这个过程中数据被别人更新了，你是不能直接干这个操作的。这个时候，你就得走上面那个操作，查询之后就不能让别人更新了。



但是真有这种场景，推荐还是用乐观锁。悲观锁实现简单一点，但是太有风险了，很容易死锁。比如事务 A 拿了数据 1 的锁，事务 B 拿了数据 2 的锁，然后事务 A 又要获取数据 2 的锁就会等待，事务 B 又要获取数据 1 的锁，也会等待。此时就会造成死锁，互相等待，永不释放。



## 死锁

事务 A：

SELECT * FROM table WHERE id = 1 FOR UPDATE



事务 B：

SELECT * FROM table WHERE id = 2 FOR UPDATE



事务 A：

 SELECT * FROM table WHERE id = 2 FOR UPDATE



事务 B：

SELECT * FROM table WHERE id = 1 FOR UPDATE



常见的死锁就是类似上面那种，给大家说过了，分别都持有一个锁，结果还去请求别人的那把锁，结果就是谁也出不来，死锁了。



情况太多，不一一列举了，就说一下发现死锁的时候怎么排查。



其实就是看死锁日志就可以了，然后根据对应的 SQL，找一下对应的代码，具体判断一下为啥死锁了。

