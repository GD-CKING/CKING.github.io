---
title: MySQL 索引设计实战
date: 2020-07-10 17:51:25
tags: MySQL
categories: MySQL
---

这个实战我们以陌生人社交 APP 为例。社交 APP，它本身的核心主旨，就是你进入 APP 的时候，需要录入一系列你的个人信息。接着 APP 自己会通过一定的算法推荐一些可能适合你的人给你进行线上交友。当然自己也可以通过一定的条件去搜索和筛选，查找 APP 上符合你期望的人



这里先忽略 APP 基于算法自动推荐潜在感兴趣的好友的部分，就看一下通过一系列的条件去筛选好友的过程。首先我们要有个用户表，叫做 `user_info`，大致会包含你的地区（这个很重要，同城方便线下见面）、性别、年龄、身高、体重、兴趣爱好、性格特点、照片等等，当然肯定还有最近一次在线时间（否则半年都不上线 APP 了，搜出来干啥）。另外如果支持交友过程中让其他人对他进行评价，那么还需要包含这个人的一个综合评分



针对这个用户表搜索，除了 `SELECT xx FROM user_info WHERE xx = xx` 有一系列的条件之外，还要支持分页展示，所以还得跟上 `LIMIT xx, xx` 的分页语句。同时，你搜索的时候，还要根据一定的规则对筛选出来的结果进行一个排序，把最符合你的条件和期望的用户排列在最上面



所以最终你的 SQL 语句可能是类似 `SELECT xx FROM user_info WHERE xx = xx ORDER BY xx LIMIT xx, xx`。这里就出现了一个难题，之前学习索引的时候，你在 where 条件里必须是实用联合索引里最左侧开始的连续多个字段进行筛选，然后排序的时候也必须是用联合索引里最左侧开始的多个连续字段进行排序



那问题来了，假设你的 SQL 需要按照年龄进行范围筛选，同时需要按照用户的评价排序，类似这样的 SQL ：`SELECT xx FROM user_info WHERE age BETWEEN 20 AND 25 ORDER BY score`，那就有问题了。假设你就一个联合索引，`age` 在最左侧，那你的 where 是可以用上索引来筛选的，但是排序是基于 `score` 字段，那就不可以用索引。如果你针对 `age` 和 `score` 分别设计两个索引，但是再你的 SQL 里假设基于 `age` 索引进行筛选，是没法领用另一个 `score` 索引进行排序的



所以，你要明白第一个难题就是：**往往在类似的 SQL 里，你的 where 筛选和 order by 排序实际上大部分是没法用到索引的**



## WHERE 还是 order by

在 where 和 order by 出现索引设计冲突的时候，到底是针对 where 去设计索引，还是针对 order by 去设计索引？



这种时候往往都是让 where 条件去使用索引来快速筛选出来一部分指定的数据，接着再进行排序，最后针对排序后的数据拿出来一页数据。因为基于索引进行 where 筛选往往可以是最快速度筛选出你要的少部分数据，如果筛选出来的数据量不是很大的话，那么后续排序和分页的成本往往不会太大



好，假设我们针对 where 条件去设计索引，那么用户在搜索潜在好友的时候，一般会用上哪些条件呢？即，我们要把哪些字段包含到联合索引里去。其实，我们首先应该在联合索引里包含 省份、城市、性别 这三个字段，因为这三个字段都是在搜索里机会必定包含的三个字段。



但是之前说过，基数太低的字段最好别放到索引里去，那 省份、城市和性别，都是基数非常小的几个字段，可选的值就那么几个，为什么要放到索引里去？



这是个好问题，但是规则是死的，人是活的。假设你就因为省份、城市和性别几个字段的基数太小了，此时就不把它们包含到联合索引去，那么你实际查询的时候都要基于这几个字段去搜索，此时你只能把这几个字段放在 where 条件的最后，那么最后每次查询都必须要先用联合索引查询出来一部分数据，接着数据加载到内存里去，再根据 where 条件最后的省份、城市和性别这几个字段进行过滤筛选，每次查询都要多这么一个步骤



所以与其如此，还不如把省份、城市和性别三个字段，放在联合索引的最左侧，这样跟其他字段组合联合索引之后，让大部分的查询都可以直接通过索引树就可以把 where 条件指定的数据筛选出来



## 范围查询

接着我们的联合索引已经设计为 (province, city, sex) 的样子。假设我们查询的时候，不指定性别，就指定了省份、城市，还有年龄，即 `WHERE province = xx AND city = xx AND age BETWEEN xx AND xx` 此时 age 不在索引里，所以根本没法通过 age 去索引里进行筛选



如果把索引设计成 (province, city, sex, age)，此时上面的 SQL 语句也是没法让 age 用上索引的，因为 city 和 age 中间差了一个 sex，所以此时就不符合最左侧连续多个字段的原则了。其实，我们完全是可以把 age 放入联合索引的。设计成 (province, city, sex, age) 这样的索引，那么在搜索的时候就根据省份、城市和年龄来筛选，性别是不限的，此时可以把 where 语句写成：WHERE province = xx AND city = xx AND sex IN('female', 'mail') and age >= xx AND age <= xx



如果我们把 SQL 语句写成这样，那么就可以让整个 WHERE 语句里的条件全部在索引树里进行筛选和搜索了。另外，假设我们在查询语句里还有一些频繁使用的条件，通常都是兴趣爱好和性格特点，这些往往都是由固定的一些枚举值的。那么针对这样的一些频繁使用的包含枚举值范围的一些字段，也可以加到联合索引里去，可以设计成 (province, city, sex, hobby, character, age) 这样的一个索引。假设此时出现了这样一个查询，按照省份、城市、性格和年龄进行搜索，此时 SQL 怎么写？



还是用之前的策略和思路，就是写成 `WHERE province = xx AND city = xx AND sex in (xx, xx) AND hobby in (xx, xx, xx) AND character = xx AND age >= xx AND age <= xx`。即，就算你不需要按性别和爱好进行筛选，但是在 SQL 里你可以对这两个字段用 in 语句，把它们所有的枚举值都放进去，这样就可以顺利地让 province、city、character 和 age 四个真正要筛选的字段用上索引。



为什么 age 字段必须放在联合索引的最后一个？因为之前我们讲索引使用规则的时候说过，假设你 where 语句里有等值匹配，还有范围搜索，此时必须是先让联合索引最左侧开始的多个字段使用等值匹配，接着最后一个字段是范围匹配。



假设你在联合索引里把 age 放在中间的位置，设计一个类似 (province, city, sex, age, hobby, character) 的联合索引，接着 SQL 写成 `WHERE province = xx AND city = xx AND sex in(xx, xx) AND age >= xx AND age <= xx AND hobby in (xx, xx, xx, xx) AND character = xx` 的话，那么只有 province、city、sex 和 age 几个字段用上索引。因为在 SQL 里，一旦你的一个字段做范围查询用到了索引，那么这个字段接下来的条件都不能用索引了，这就是规则



所以，实际设计索引的时候，必须把经常用作范围查询的字段放在联合索引的最后一个，才能保证你 SQL 里每个字段都能基于索引去查询



## 用于辅助的索引

接着，假设在查询的时候还有一个条件，是要根据用户最近登录时间在 7 天之内来进行筛选，筛选最近 7 天登录过 APP 的用户，那么可能你用户表有这么一个字段：`latest_login_time`。



你要是在 where 条件里加入这么一个 latest_login_time <= 7 天内语句，肯定是没法用上索引的，因为这里必然会用一些计算或者是函数，才能进行一些时间的比对。而且假设你的查询里还有 age 进行范围查询，那么范围查询的时候，也就只有第一个范围查询时可以用上索引的，第一个范围查询之后的其它范围查询时用不上索引的



即，你索引设计成这样：(province, city, sex, hobby, character, age, latest_login_time)，然后你的 where 语句写成这样：`WHERE xx xxx AND age >= xx AND age <= xx AND latest_login_time >= xx`，虽然 age 和 latest_login_time 都在联合索引里，但是按照规则，只有 age 范围查询可以用到索引，latest_login_time 是用不到索引的



此时有一个技巧，你在设计表的时候，就要考虑到这个问题，此时你可以设计一个字段：does_login_in_latest_7_days，即，这个人是否在最近 7 天内登陆过 APP。假设在 7 天内登陆过 APP，那么这个字段就是 1，否则就是 0。这样就把一个时间字段转化为了一个枚举字段



接下来就简单了，设计一个联合索引：(province, city, sex, hobby, character, does_login_in_latest_7_days, age)，然后搜索的时候再 where 条件里带上一个 does_login_in_latest_7_days = 1，最后跟上 age 范围查询，这样就可以让你的字段都用索引来筛选了



一般来说，假设你 where 语句里通过上述联合索引就可以过滤掉大部分的数据，就保留小部分数据下来基于磁盘文件进行 order by 语句的排序，最后基于 limit 进行分页，那么一般情况下性能还是比较高的。但是，万一你仅仅使用联合索引里一些基数特别小的字段来筛选呢？



比如就基于性别来筛选，假设一下子筛选出所有的女性，可能有上百万用户数据，接着还要根据磁盘文件进行排序在分页，此时性能就很差了。



所以针对上述问题，可以针对那种基数很低的字段再加上排序字段单独设计一个辅助索引，专门用于解决 where 条件里都是基数低的字段，然后还要排序后分页的问题，比如可以设计一个联合索引为：(sex, score)。此时你写出如些 SQL：`SELECT xx FROM user_info WHERE sex = 'female' ORDER BY score LIMIT xx, xx`。此时如果还用之前设计的索引，那就没了，因为根本没法用索引



但是用我们设计的那个辅助的 (sex, score) 索引，因为此时 where 条件里的字段是等值匹配，而且还是等于某个常量值，所以虽然 order by 后跟的 score 字段是 (sex, score) 索引里的第二个字段，order by 没有从索引最左侧字段开始排列，但是它也可以使用到索引来排序。



因为具体到使用索引的层面，它会先对 where 条件里的 `sex = 'female'` 在索引树里筛选到这部分数据，接着在 sex = 'female' 的数据里，这些数据实际上都是排列在一起的，因为在索引里，会按照 sex 和 score 两个字段去进行排序，所以 sex = 'female' 的数据都是一块的



然后找到这部分数据之后，接着就可以确定，这部分数据肯定是按照 score 字段进行排序的，此时就可以按照 score 字段值的顺序，去读取你的 limit 语句指定的数据分页出来就可以了。所以此时你针对 sex 低基数的筛选和基于评分排序的语句，整体运行的效率是非常高的，完全可以基于辅助索引来实现



总结起来就是，可以通过对查询场景的分析，用 (province, city, sex, hobby, character, does_login_in_latest_7_days, age) 这样的联合索引去抗下复杂的 where 条件筛选的查询，此时走索引筛选速度很快，筛选出来的数据量较少，接着进行排序和 limit 分页



通过针对一些低**基数字段筛选 + 评分排序**的查询场景，可以设计类似 (sex, score) 的辅助索引来应对，让它快速定位到一大片低基数字段对应的数据，然后按照索引顺序去 limit 语句获取指定分页的数据，性能一样会很好



**核心重点就是，尽量使用一两个复杂的多字段联合索引，抗下 80% 以上的查询，然后用一两个辅助索引抗下剩余 20% 非典型查询，保证 99% 以上查询都能充分利用索引，就能保证你的查询速度和性能**







