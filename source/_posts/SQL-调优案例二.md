---
title: SQL 调优案例二
date: 2020-09-24 16:24:53
tags: MySQL
categories: MySQL
---

## 案例背景

先从一个线上的商品系统出现的一个慢查询告警开始讲起。一天晚上，我们收到了线上数据库的频繁报警，这个报警的意思是，数据库突然涌现出了大量的慢查询，而且因为大量的慢查询，导致每一个数据库连接执行一个慢查询都要耗费很久。那样，必然会导致突然过来的很多查询需要让数据库开辟出来更多的连接，因此这个时候报警也告诉我们，数据库的连接突然暴增了，而且每个连接都打满，每个连接都要执行一个慢查询，慢查询还特别慢



接着引发的问题，就是数据库的连接全部打满，没法开辟新的连接，但是还持续地有新的查询发送过来，导致数据库没法处理新的查询，很多查询发送数据库直接就阻塞然后超时了，这也直接导致了线上的商品系统频繁地报警，出现了大量的数据库查询超时报错的异常



这种情况，基本意味着你的系统濒临于崩溃了，大量慢查询耗尽了数据库的连接资源，而且一直阻塞在数据库里执行，数据库没法执行新的查询。那么慢查询的都是一些什么语句呢？其实主要就是下面的这条语句，我们做了一个简化：

```mysql
SELECT * FROM products WHERE category = 'xx' AND sub_category = 'xx' ORDER BY id DESC LIMIT xx, xx
```



这是一个很稀松平常的 SQL 语句，它就是用户在电商网站上根据商品的品类以及子类在进行筛选，当然真是的 SQL 语句里，可能还包含其他的一些子段的筛选，比如品牌之类的，我们这里做了一个简化，然后按照 id 倒序排序，最后是分页，就这么一个语句



然后语句执行的商品表里大致是 1 亿左右的数据量，这个量级已经稳定了很长时间了，主要也就是这么多商品，但是上面的那个语句一执行就是几十秒



## SQL 优化

接着我们分析一下，为什么会出现这样的一个情况。首先，这个表当时肯定是对经常用到的查询字段都建立好索引的，那么针对这里简化后的 SQL 语句，你可以认为存在这样的一个索引：KEY index_category(category, sub_category)，所以基本可以确认上面的 SQL 绝对是可以用上索引的



一旦你用上了品类的索引，那么按品类和子类在索引里筛选，第一，筛选很快速；第二，晒出来的数据是不多的，按说这个语句应该执行的速度是很快的，即使表有亿级数据，但是执行时间也最多不超过 1s



但是这个 SQL 语句跑了几十秒，说明它肯定没有用我们建立的那个索引，那么它是怎么执行的，看一下它的执行计划：

```mysql
EXPLAIN SELECT * FROM products WHERE category = 'xx' AND sub_category = 'xx' ORDER BY id DESC LIMIT xx, xx
```



执行计划具体内容就不写了，这里说最核心的信息。它的 possible_keys 里是有我们的 index_category 的，结果实际上用的 key 不是这个索引，而是 PRIMARY，而且 extra 里写了 Using where



到此为止，我们就知道为什么这个 SQL 语句性能那么差了。它其实本质上就是在主键的聚簇索引上进行扫描，一边扫描，一边还用了 where 条件里的两个字段去进行筛选，所以这么扫描的话，必然是会耗费几十秒了



因为为了快速解决这个问题，就需要强制性地改变 MySQL 自动选择这个不合适的聚簇索引进行扫描的行为。怎么改变？可以使用 `force index` 语法，如下：

```mysql
SELECT * FROM products FORCE INDEX(index_category) WHERE category = 'xx' AND sub_category = 'xx' ORDER BY id DESC LIMIT xx, xx
```



使用上述语法过后，强制让 SQL 语句使用了你指定的索引，此时再次执行这个 SQL 语句，会发现它仅仅耗费 100 多毫秒，性能瞬间就提升上去了



这是一个实战技巧，就是你如何去强制改变 MySQL 的执行计划。如果 MySQL 使用了错误的执行计划，应该怎么办？方法就是 `force index` 语法就可以



这个案例还没完，还遗留很多问题：

- 为什么这个案例中 MySQL 会默认选择对主键的聚簇索引进行扫描

- 为什么没使用 index_category 这个二级索引进行扫描

- 即使用了聚簇索引，为什么这个 SQL 以前没有问题，现在突然就有问题了



## 问题分析

接着我们分析上面的那些问题。首先，第一个问题，为什么针对 `SELECT * FROM products WHERE category = 'xx' AND sub_category = 'xx' ORDER BY id DESC LIMIT xx, xx` 这样一个 SQL 语句，MySQL 要选择对聚簇索引进行扫描呢？



首先，这个表是一个亿级数据量的大表，那么针对它来说，index_category 这个二级索引也是比较大的。所以此时对于 MySQL 来说，它有这么一个判断，它觉得如果要是从 index_category 二级索引里查找到符合 where 条件的一波数据，接着还得回表，回到聚簇索引里去



因为 SQL 语句是要 select * 的，所以这里必然涉及到一次回表操作，回到聚簇索引里去把所有字段的数据都查出来，但是在回表之前，它必然要做完 order by id desc limit xx, xx 这个操作



举个例子，比如它根据 `where category = 'xx' and sub_category = 'xx'`，从 index_category 二级索引里查找出了一大波数据，比如从二级索引里搂出来几万条数据，接着而已二级索引里是包含主键 id 值的，所以此时它就得按照 order by id desc 这个排序语法，对这几万条数据基于临时磁盘文件进行 filesort 磁盘排序，排序完了之后，再按照 limit xx, xx 语法，把指定位置的几条数据拿出来。假设是 limit 0, 10，那么就是拿出来 10 条数据



拿出来 10 条数据之后，再回到聚簇索引里去根据 id 查找，把这 10 条数据的完整字段都查出来，这就是 MySQL 认为你使用 index_category 的话，可能会发生的一个情况



所以它担心的是，你根据 `where category = 'xx' and sub_category = 'xx'`，从 index_category 二级索引里查出来的数据太多了，还得在临时磁盘里排序，可能性能会很差，因此 MySQL 就把这种方式判定为不太好的方式



因此它才会选择一种方式，即，直接扫描主键的聚簇索引，因为聚簇索引都是按照 id 值有序的，所以扫描的时候，直接按 order by id desc 这个倒序顺序扫描过去就可以了，因为知道你是 limit 0, 10，也就知道你仅仅只要拿到 10 条数据就行了



所以它在按顺序扫描聚簇索引的时候，就会对每一条数据都采用 Using where 的方式，跟 where category= 'xx' and sub_category = 'xx' 条件进行对比，符合条件的就直接放入结果集里去，最多就是放 10 条数据进去就可以返回了



此时 MySQL 认为，按顺序扫描聚簇索引，拿到 10 条符合 where 条件的数据，应该速度是很快的，很可能比使用 index_category 二级索引那个方案更快，因此它就采用了扫描聚簇索引的这种方式。



那这个 SQL 语句之前在线上运行一直没问题，即之前在线上系统而言，即使采用扫描聚簇索引的方案，这个 SQL 语句也确实一般都运行不慢，起码是不会超过 1s 的。那么为什么会在某一天晚上突然的就报大量的慢查询，耗时几十秒呢？



因为之前 `where category = 'xx' and sub_category = 'xx'` 这个条件通常都是有返回值的，就是说根据条件里的取值，扫描聚簇索引的时候，通常都是很快能找到符合条件的值以及返回的，所以之前其实性能也没什么问题。但是后来可能是商品系统里的运维人员，在商品管理的时候加了几种商品分类和子类，但是这几种分类和子类的组合其实没有对应的商品



也就是说，那一天晚上，很多用户使用这种分类和子类去筛选商品，`where category = '新分类' and sub_category = '新子类'` 这个条件实际上是查不到任何数据的。所以说，底层在扫描聚簇索引的时候，扫来扫去都扫不到符 where 条件的结果，一下子就把聚簇索引全部扫描了一遍，等于是上亿数据全表扫描了一遍，都没有找到符合 `where category = '新分类' and sub_category = '新子类'` 这个条件的数据



也正是因为如此，才导致这个 SQL 语句频繁地出现几十秒的慢查询，进而导致 MySQL 连接资源被打满，商品系统崩溃