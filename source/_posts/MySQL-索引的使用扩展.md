---
title: MySQL 索引的使用扩展
date: 2020-07-09 14:57:12
tags: MySQL
categories: MySQL
---

## SQL 排序的时候如何使用索引

假设你有一个 `SELECT * FROM table WHERE xxx = xxx ORDER BY xxx` 这样的一个 SQL 语句，似乎应该是基于 where 语句通过索引快速筛选出来一波数据，接着放到内存里，或者放到一个临时文件里，然后通过排序算法按照某个字段走一个排序，最后把排序好的数据返回



但这么搞是有点慢的，尤其是你要排序的数据量比较大，还不能用内存来排序。如果基于磁盘文件来排序，那在 MySQL 里有一个术语，叫做 `filesort`，这速度就比较慢了。所以尽量被这么处理，尤其是类似于 `SELECT * FROM table ORDER BY xx1, xx2, xx3 LIMIT 100` 这样的 SQL 语句，按照多个字段排序然后返回去排名前 100 条数据，类似的语句常常见于分页 SQL 语句，可能需要对表里的数据进行一定的排序，然后走一个 limit 拿出来指定部分的数据



你要是纯粹把数据放到一个临时磁盘文件里，然后直接各种排序算法在磁盘文件里搞一通排序，接着按照你指定的要求走 limit 语句拿到指定分页的数据，那会让 SQL 的速度非常慢。所以通常而言，假设我们建立了一个索引 `INDEX(xx1, xx2, xx3)` 这样的一个联合索引，这个时候默认情况下载索引树里本身就是依次按照 `xx1, xx2, xx3` 三个字段的值去排序的，那么此时你再运行 `SELECT * FROM table ORDER BY xx1, xx2, xx3 LIMIT 100` 这样的 SQL 语句，就不用在什么临时文件里排序了



因为它要求也不过就是按照 xx1, xx2, xx3 三个字段来进行排序而已，在联合索引的索引树都排序好了，直接按照索引树里的顺序，把 xx1, xx2, xx3 三个字段从小到大的值获取前面 100 条就可以了，然后拿到 100 条数据的主键再去聚簇索引里回表查询剩余所有的字段



因此，在你的 SQL 语句里，应该尽量按照联合索引的字段顺序去进行 order by 排序，这样就可以直接利用联合索引里的数据有序性，到索引树里直接按照字段值的顺序去获取你需要的数据了。但是这里有一些限定规则，因为联合索引里的字段值在索引树里都是从小到大依次排列的，所以你在 order by 里要不就是每个字段后面什么都不加，直接就是 `order by xx1, xx2, xx3`，要不然就都加 `DESC` 降序排列，就是 `order by xx1 DESC, xx2 DESC, xx3 DESC`



如果都是升序排列，直接就从索引树里最小的开始读取一定条数就可以了，要是都是降序排列，就是从索引树里最大的数据开始读取一定的条数就可以了，但是你不能 order by 语句里有的字段升序有的字段降序，那是不能用索引的。另外，要是你 order by 语句有的字段不在联合索引里，或者是你对 order by 语句里的字段用了复杂的函数，这些也不能使用索引去进行排序



## SQL 分组的时候如何使用索引

接着我们讲讲如果 SQL 语句里用到 group by 分组词句的话是否可以用上索引



假设你走一个类似 `SELECT COUNT(*) FROM table GROUP BY xx` 的 SQL 语句，似乎看起来必须把你所有的数据放到一个临时磁盘文件里还有加上部分内存，去搞一个分组，按照指定字段的值分成一组一组的，接着对每一组都执行一个聚合函数。这个性能也是很差的，毕竟涉及大量的磁盘交互



因为我们的索引树里默认都是按照指定的字段都排序好的，其实字段值相同的数据都是在一起的，假设要是走索引去执行分组后再聚合，性能一定是比临时磁盘文件去执行好多了。所以对于 group by 后的字段，最好也是按照联合索引里的最左侧的字段开始，按顺序排列开来，这样，就可以完美运用索引来直接提取一组一组的数据，然后针对每一组的数据执行聚合函数即可



其实大家会发现，这个 group by 和 order by 用上索引的原理和条件都是差不多的，本质都是在 group by 和 order by 之后的字段顺序和联合索引中的从最左侧开始的字段顺序一致，然后就可以充分利用索引树已经完成排序的特性，快速地根据排序好的数据执行后续操作了。这样就不用针对杂乱无章的数据利用临时磁盘文件加上部分内存数据结构进行耗时耗力的现场排序和分组。



到这里，大家应该理解了一点，就是我们平时设计表里的索引的时候，必须充分考虑到后续的 SQL 语句要怎么写，大概率会根据哪些子段来进行 where 语句里的筛选和过滤？大概会根据哪些字段来进行排序和分组。然后在考虑后之后，就可以为表设计两三个常用的索引，覆盖常见的 where 筛选，order by 排序和 group by 分组的需求，保证常见的 SQL 语句都可以用上索引，这样你系统跑起来，是不会有太大的查询性能问题如果查询还是有问题，就需要深度理解查询的执行计划和执行原理了，然后基于执行计划来进行深度 SQL 调优。



顺便扩展一下，对于更新而言，其实最核心的就是三大问题，一个是你索引别太多，索引太多了，更新的时候维护很多索引树肯定是不行的；一个是可能会涉及到一些锁等待和死锁的问题；一个就是可能会涉及到 MySQL 连接池、写 redo log 文件之类的问题



## 回表查询对性能的损害以及覆盖索引

一般我们自己建的索引不管是单列索引还是联合索引，其实一个索引就对应着一棵独立的索引 B+ 树，索引 B+ 树的节点仅仅包含着索引里的几个字段的值以及主键值。即使我们根据索引树找到了需要的数据，那也仅仅是索引里的几个字段的值和主键值。如果你搞了个 `SELECT *` 还需要很多其他的字段，那还要走一个回表操作，根据主键跑到主键的簇簇索引里去找，聚簇索引的叶子节点是数据页，找到数据页才能把一行数据的所有字段值提取出来



所以类似 `SELECT * FROM table ORDER BY xx1, xx2, xx3 `的语句，可能你就得从联合索引的索引树里按照顺序取出所有数据，接着对每一条数据都走一个主键的聚簇索引的查找，其实性能也是不高的



有的时候 MySQL 的执行引擎可能会认为，类似 `SELECT * FROM table ORDER BY xx1, xx2, xx3` 的语句，相当是把联合索引和聚簇索引，两个索引的所有数据都扫描一遍，那还不如不走联合索引，直接全表扫描，这样还就扫描一个索引而已



但是你如果是 `SELECT * FROM table ORDER BY xx1, xx2, xx3 LIMIT 10` 这样的语句，那执行引擎就知道，你先扫描联合索引的索引树拿到 10 条数据，接着对 10 条数据在聚簇索引里查找 10 次就可以了，那么还是会走联合索引的。这个原理大家要知道



其次，就是要讲一下覆盖索引的概念。其实覆盖索引不是一种索引，它就是一种基于索引查询的方式罢了。



针对类似 `SELECT xx1, xx2, xx3 FROM table ORDER BY xx1, xx2, xx3` 这样的语句。这种情况下，你仅仅需要联合索引里的几个字段的值，那么其实只要扫描联合索引的索引树就可以了，不需要回表去聚簇索引里找其它字段了。所以这个时候，需要的字段直接在索引树里就能提取出来，不需要回表到聚簇索引，这种查询方式就是覆盖索引



所以在写 SQL 的时候，一方面你要注意一下也许你会用到联合索引，但是是否可能会导致大量的回表到聚簇索引，如果需要回表到聚簇索引的次数太多了，可能就直接给你做成全表扫描不走联合索引了。



一方面是尽可能还是在 SQL 里指定你仅仅需要的几个字段，不要搞一个 `SELECT *` 把所有字段都拿出来，甚至最好是直接走覆盖索引的方式，不要回表到聚簇索引。即使真的要回表到聚簇索引，那也尽可能用 LIMIT、WHERE 之类的语句限定一下回表到聚簇索引的次数，就熊联合索引里筛选少数数据，然后再回表到聚簇索引里去，这样性能也会好一些。

