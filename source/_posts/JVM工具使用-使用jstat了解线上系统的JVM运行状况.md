---
title: JVM工具使用-使用jstat了解线上系统的JVM运行状况
date: 2019-12-02 20:54:21
tags: JVM
categories: JVM
---

​		平时我们对运行中的系统，如果要检查他的JVM的整体运行情况，比较实用的工具是`jstat`。它可以让你看到当前运行中的系统，它的JVM内的Eden、Survivor、老年代的内存使用情况，还有Young GC和Full GC的执行次数以及耗时。通过这些指标，我们可以分析出当前系统的运行情况，判断当前系统的内存使用压力以及GC压力，还有就是内存分配是否合理。

## jstat的使用

### jstat -gc PID

​		首先要在生产机器linux上，找出Java进程的PID。接着就针对我们的Java进程执行`jstat -gc PID`。这样就可以看到这个Java进程（其实本质就是一个JVM）的内存和GC情况了。

​		运行这个命令之后会看到如下列：

```
S0C：这是From Survivor区的大小
S1C：这是To Survivor区的大小
S0U：这个From Survivor区当前使用的内存大小
S1U：这是To Survivor区当前使用的内存大小
EC：这是Eden区的大小
EU：这是Eden区当前使用后的内存大小
OC：这是老年代的大小
OU：这是老年代当前使用的内存大小
MC：这是方法区（永久代、元数据区）的大小
MU：这是方法区（永久代、元数据区）的当前使用的内存大小
YGC：这是系统运行迄今为止的Young GC次数
YGCT：这是Young GC的耗时
FGC：这是系统运行迄今为止的Full GC次数
FGCT：这是Full GC的耗时
GCT：这是所有GC的总耗时
```

### 其他的jstat命令

​		除了上面的jstat -gc命令是最常用的以外，它还有一些命令可以看到更多详细的信息：

```
jstat -gccapacity PID：堆内存分析
jstat -gcnew PID：年轻代GC分析，这里的TT和MTT可以看到对象在年轻代存活的年龄和存活的最大年龄
jstat -gcnewcapacity PID：年轻代内存分析
jstat -gcold PID：老年代GC分析
jstat -gcoldcapacity PID：老年代内存分析
jstat -gcmetacapacity PID：元数据区内存分析
```

### 如何使用jstat工具

​		一般我们分析线上JVM线程，最想知道的信息有哪些？包括如下：新生代对象增长的速率、Young GC的触发频率，Young GC的耗时，每次Young GC后有多少对象是存活下来的，每次Young GC过后有多少对象进入了老年代、老年代对象增长的速率，Full GC的触发频率，Full GC的耗时。

#### 新生代对象增长的速率

​		这其实是对JVM第一个要了解的事情，就是随着系统运行，每秒种会在年轻代的Eden区分配多少对象。要分析这个，你只要在线上linux机器上运行如下命令：`jstat -gc PID 1000 10`。它的意思是每隔一秒钟更新出最新的一行jstat统计信息，一共执行10次jstat统计。

​		通过这个命令，可以非常灵活的对线上机器通过固定频率输出统计信息，观察每隔一段时间的jvm中的Eden区对象占用变化。例如，执行这个命令后，第一秒先显示出Eden区使用了200MB内存，第二秒显示出的统计信息里，Eden区使用了205MB，第三秒显示出Eden区使用了209MB内存，以此类推。此时你就可以推断出这个系统每秒种会新增5MB左右的对象。

​		这里大家可以根据自己系统的情况灵活多变地使用，比如系统负载很低，不一定每秒都有请求，那么可以把上面的1秒钟调整为1分钟，甚至10分钟，去看你们系统每隔一定时间大概增长多少对象。还有就是一般系统都有高峰和日常两种状态，比如系统高峰期用的人很多，此时就应该用上述命令看看高峰期的对象增长率，然后还得在非高峰的日常时间段内看看对象的增长速率。

#### Young GC的触发频率和每次耗时

​		多久触发一次Young GC很容易推测出来，因为系统高峰和日常的对象增长速率都知道了，那么非常简单就可以推测出高峰期多久发生一次Young GC，日常期多久发生一次Young GC。

​		比如你Eden区有800MB内存，发现高峰期每秒新增5MB对象，大概高峰期就是3分钟会触发一次Young GC。日常期每秒新增0.5MB，那么日常期大概需要半个小时才会触发一次Young GC。

​		至于如何计算Young GC的平均耗时，jstat会告诉你迄今为止系统已经发生了多少次Young GC以及这些Young GC的总耗时。例如系统运行24小时后发生了260次Young GC，总耗时为20s，那么平均下来每次Young GC大概就耗时几十毫秒的时间，你就知道每次Young GC的时候会导致系统停顿几十毫秒。

#### 每次Young GC后有多少对象是存活和进入老年代

​		接着我们想知道每次Young GC后有多少对象会存活下来，以及有多少对象会进入老年代。这个没办法直接看出来，但有办法可以大概推算出来。

​		之前我们推算出高峰期的时候多久发生一次Young GC，比如3分钟会有一次Young GC，那么此时我们可以执行下述jstat命令：`jstat -gc 180000 10`。这就是让他每隔三分钟执行一次统计，连续执行十次。此时可以观察一下，每隔三分钟之后发生了一次Young GC，此时Eden、Survivor和老年代的对象变化。

​		正常来说，Eden区肯定会几乎放满之后重新变得里面对象很少，比如800MB的空间就使用了几十MB，Survivor区肯定会放入一些存活对象，老年代可能会增长一些对象占用，所以这里的关键，就是**观察老年代的对象增长速率**。

​		一般情况下，老年代的对象不太可能不停地快速增长的，因为普通的系统没那么多长期存活的对象，如果你发现每次Young GC过后，老年代对象都要增长几十MB，那很有可能就是你一次Young GC过后存活的对象太多了。存活的对象太多，可能导致放入到Survivor区域之后触发了动态年龄判定规则进入老年代，也可能是Survivor区域放不下了，所以大部分存活对象进入老年代。

​		最常见的情况是这种：如果你的老年代每次在Young GC过后就新增几百KB，或者几MB的对象，这个还算情有可原，但是如果老年嗲对象快速增长，那一定是不正常的。所以通过上述观察策略，你就可以知道每次Young GC过后多少对象是存活的，实际上Survivor区域里和进入老年代的对象，都是存活的。你也可以知道老年代对象的增长速率，比如每隔3分钟一次Young GC，每次会有50MB对象进入老年代，这就是老年代对象的增长速率，每隔3分钟增长50MB。

#### Full GC的触发时机和耗时

​		只要知道了老年代对象的增长速率，那么Full GC的触发时机就很清晰了。比如老年代总共有800MB的内存，每隔3分钟新增50MB对象，那么大概每小时就会触发一次Full GC。然后可以看到jstat打印出来的系统运行迄今为止的Full GC次数以及总耗时，比如一共执行了10次Full GC，总耗时30s，每次Full GC大概就是需要耗费3s左右。