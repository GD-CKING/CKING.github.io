---
title: MySQL 多事务运行场景
date: 2020-06-22 10:53:35
tags: MySQL
categories: MySQL
---

平时我们执行增删改的时候，无非就是从磁盘加载数据到 buffer pool 的缓存页里去，对缓存页进行更新，同时记录下来 undo log 回滚日志和 redo log 重做日志，应对的是事务提交之后 MySQL 挂了恢复数据的场景，以及事务回滚的场景



接下来我们就要理解到「事务」这个层面了。平时我们一般都是写一个业务系统，然后业务系统对去对数据库执行增删改查，然后通常而言，我们都是在业务系统里开启事务来执行增删改操作的，如下：

```java
@Transactional
public void doService() {

	// 增加一条数据
	addUser();
	
	// 修改一条数据
	updateUser();
	
	// 删除一条数据
	deleteUser();
}
```



所以一般来说，业务系统是执行一个一个的事务，每个事务里可能是一个或者多个增删改查的 SQL 语句。这个事务的概念就不用多说了，其实就是一个事务里的 SQL 要么一起成功就提交了，要不然有一个 SQL 失败，那么事务就回滚了，所有 SQL 做的修改都撤销了。



接着问题来了，这个业务系统不是一个单线程系统，他是有很多线程的，因为它面向的终端用户是有很多人的，可能会同时发起多个请求，所以它需要多个线程并发来处理多个请求的。于是，这个系统和可能是基于多线程并发地对 MySQL 数据库去执行多个事务的。如图：

![业务系统](MySQL-多事务运行场景/业务系统.png)



那么每个事务里面的多个 SQL 语句是如何执行的？其实就是我们之前给大家讲的那一套原理了，包括从磁盘加载数据到 buffer pool 的缓存页里去，然后更新 buffer pool 里的缓存页，同时记录 redo log 和 undo log，如图：

![基本原理](MySQL-多事务运行场景/基本原理.png)



每个事务如果提交了，那就皆大欢喜。如果事务提交之后，redo log 刷入磁盘，结果 MySQL 宕机了，是可以根据 redo log 恢复事务修改过的缓存数据的。如果要回滚事务，那么就基于 undo log 来回滚就可以了，把之前对缓存页做的修改都给回滚了就可以了。



这就是 MySQL 内核层面，把多个事务和我们讲解的 buffer pool、redo log、undo log 几个机制都结合在一起的一个场景讲解。



但是这里就有很多问题了：

- 多个事务并发执行的时候，可能会同时对缓存页里的一行数据进行更新，这个冲突怎么处理？是否要加锁？

- 可能有的事务在一行数据做更新，有的事务在查询这行数据，这里的冲突怎么处理



## 脏写和脏读

上面说到，对于我们的业务系统去访问数据库而言，它往往是多个线程并发执行多个事务的，对于数据库而言，它会有多个事务同时执行，可能这多个事务还会同时更新和查询同一条数据，所以这里会有一些问题需要数据库来解决



我们来看看，如果多个事务要是对缓存里的同一条数据同时进行更新或者查询，此时会产生哪些问题呢？这里实际上会涉及到**脏写、脏读、不可重复读、幻读**四种问题。



### 脏写

脏写，意思是说有两个事务，事务 A 和事务 B 同时在更新一条数据，事务 A 先把它更新为 A 值，事务 B 紧接着就把它更新为 B 值。如图：

![更新数据](MySQL-多事务运行场景/更新数据.png)



可以看到，此时事务 B 是后更新那行数据的值，所以此时那行数据的值是 B。而且此时事务 A 更新之后会记录一条 undo log 日志。因为事务 A 是先更新的，它在更新之前，这行数据的值为 `NULL`。所以此时事务 A 的 undo log 日志大概就是：更新之前这行数据的值为 NULL，主键为 XX



那么此时事务 B 更新完数据的值为 B，此时事务 A 突然回滚了，就会用它的 undo log 日志去回滚。此时事务 A 一回滚，直接就会把那行数据的值更新回 NULL 值。如图：

![脏写](MySQL-多事务运行场景/脏写.png)



然后就尴尬了，事务 B 一看，为什么我更新的 B 值没了？就因为你事务 A 反悔了把数据值回滚成 NULL 了，结果我更新的 B 值也不见 了。所以对于事务 B 看到的场景而言，就是自己明明更新了，结果值却没了，**这就是脏写。**



所谓脏写，就是我刚才明明写了一个数据值，结果过了一会却没了。而它的本质就是事务 B 去修改了事务 A 修改过的值，但是此时事务 A 还没提交，所以事务 A 随时会回滚，导致事务 B 修改的值也没了，这就是脏写的定义。



### 脏读 

假设事务 A 更新了一行数据的值为 A 值，此时事务 B 去查询了一下这行数据的值，看到的值是 A 值，如图：

![查询数据](MySQL-多事务运行场景/查询数据.png)



接着，事务 B 拿着刚才查询到的 A 值做各种业务处理。但是接着坑爹的事情发生了，事务 A 突然回滚了事务，导致它刚才功能的 A 值没了，此时那行数据的值回滚为 NULL 值。然后事务 B 紧接着此时再次查询那行数据的值，看到的居然是 NULL 值。如图：

![脏读](MySQL-多事务运行场景/脏读.png)



这就是脏读。它的本质是事务 B 去查询了事务 A 修改过的数据，但是此时事务 A 还没提交，所以事务 A 随时会回滚导致事务 B 再次查询就读不到刚才事务 A 修改的数据了，这就是脏读。



其实总结一句话，**无论是脏写还是脏读，都是因为一个事务去更新或者查询了另外一个还没提交的事务更新过的数据。因为另外一个事务还没提交，所以它随时可能会回滚，那么必然导致你更新的数据就没了，或者你之前查询到的数据就没了，这就是脏写和脏读两种场景。**



## 不可重复读

假设我们有一个事务 A 开启了，在这个事务 A 里会多次对一条数据进行查询。然后呢，另外有两个事务，一个是事务 B，一个是事务 C，他们两都是对一条数据进行更新的。然后我们假设一个前提，就是比如说事务 B 更新之后，如果还没提交，那么事务 A 是读不到的，必须要事务 B 提交之后，它修改的值才能被事务 A 读取到，其实这种情况下，就是我们首先避免了脏读的发生



因为脏读的意思就是事务 A 可以读到事务 B 修改过还没提交的数据，此时事务 B 一旦回滚，事务 A 再次读就读不到了，那么此时就会发生脏读问题。我们现在假设的前提是事务 A 只能在事务 B 提交之后读取到它修改的数据，所以此时必然是不会发生脏读的



但是，此时会有另外一个问题，叫做**不可重复读**。假设缓存页里一条数据原来的值是 A 值，此时事务 A 开启之后，第一次查询这条数据，读取到的就是 A 值。如图：

![查询1](MySQL-多事务运行场景/查询1.png)



接着事务 B 更新了那行数据的值为 B 值，同时事务 B 立马提交了，然后事务 A 此时还没提交。大家注意，此时事务 A 是没提交的，它在事务执行期间第二次查询数据，此时查到的是事务 B 修改过的值，B 值，因为事务 B 已经提交了，所以事务 A 是可以读到的，如图：

![查询2](MySQL-多事务运行场景/查询2.png)



紧接着事务 C 再次更新数据为 C 值，并且提交事务了，此时事务 A 在还没提交的情况下，第三次查询数据，查到的值为 C 值，如下：

![查询3](MySQL-多事务运行场景/查询3.png)



那么上面的场景有什么问题呢？其实要说没问题也可以是没问题的，毕竟事务 B 和 事务 C 都提交之后，事务 A 多次查询查到它们修改的值，是 OK 的。但是你要说有问题，也可以是有问题的，就是事务 A 可能第一次查询到 A 值，那么它可能希望的是在事务执行期间，如果多次查询数据，都是同样的一个 A 值，它希望这个 A 值是它重复读取的时候一直可以读到的。它希望这行数据的值是可重复读的



但是此时，明显 A 值是不可重复读的。因为事务 B 和事务 C 一旦更新值并且提交了，事务 A 会读到别的值，所以此时这行数据的值是不可重复读的。此时对于你来说，这个不可重复读的场景，就是一种问题



上面描述的，其实就是不可重复读的问题，其实这个问题你说是问题也不一定就是什么大问题。因为这取决于你自己想要数据库是什么样子的，如果你希望看到的场景是不可重复读，也就是事务 A 在执行期间多次查询一条数据，每次都可以查到其它已经提交的事务修改过的值，那么就是不可重复读，如果你希望这样子，那也没问题。



如果你期望的是可重复读，但是数据库表现的是不可重复读，让你事务 A 执行期间多次查到的值都不一样，都的问题是别的提交过的事务修改过的，那么此时你就可以认为，数据库有问题，这个问题就是「不可重复读」



## 幻读

脏写、脏读和不可重复读都分别代表了不同的数据库问题。脏写就是两个事务没提交的状况下，都修改同一条数据，结果一个事务回滚了，把另外一个事务修改的值也撤销了，所谓脏写就是两个事务没提交状态下修改同一个值。



脏读就是一个事务修改了一条数据的值，结果还没提交呢，另外一个事务就读到了你修改的值，然后你回滚了，人家事务再次读，就读不到了，即人家事务读到了你修改之后还没提交的值，这就是脏读了。而不可重复读，针对的是已经提交的事务修改的值，被你事务给读到了，你事务内多次查询，多次读到的是别的已经提交的事务修改过的值，这就导致不可重复读。



接着我们说说**幻读**。简单来说，你一个事务 A，先发送一条 SQL 语句，里面有一个条件，要查询一批数据出来，如 `SELECT * FROM table WHERE id > 10`。然后呢，它一开始查询出来了 10 条数据。接着这个时候，别的事务 B往表里插了几条数据，而且事务 B 还提交了，此时多了几行数据。如图：

![幻读1](MySQL-多事务运行场景/幻读1.png)



接着事务 A 此时第二次查询，再次按照之前的一模一样的条件执行 `SELECT * FROM table WHERE id > 10` 这条 SQL 语句，由于其他事务插入了几条数据，导致这次它查询出来了 12 条数据。如图：

![幻读2](MySQL-多事务运行场景/幻读2.png)



于是事务 A 开始怀疑自己的眼镜了，为什么一模一样的 SQL 语句，第一次查询是 10 条数据，第二次查询是 12 条数据？难道刚才出现幻觉了？这就是「幻读」这个名词的由来



幻读就是你一个事务用一样的 SQL 多次查询，结果每次查询都会发现查到一些之前没看到过的数据。注意，幻读特指的是你查询到了之前查询没看到过的数据。此时说明你是幻读了



其实，脏写、脏读、不可重复读、幻读，都是因为业务系统会多线程并发执行，每个线程可能都会开启一个事务，每个事务都会执行增删改查操作。然后数据库会并发执行多个事务，多个事务可能会并发地对缓存页里的同一批数据进行增删改查操作，于是这个并发增删改查同一批数据的问题，可能就会导致我们说的脏写、脏读、不可重复读、幻读这些问题。



所以这些问题的本质，都是数据库的多事务并发问题，那么为了解决多事务并发问题，数据库才设计了事务隔离机制、MVCC 多版本隔离机制、锁机制，用一整套机制来解决多事务并发问题。