---
title: TCP 的三次握手和四次挥手
date: 2020-02-11 17:00:14
tags: 计算机网络
categories: 计算机网络
---

## TCP 三次握手

客户端与服务端通过传输层的 tcp 协议建立网络连接的时候，其实走的是三次握手的过程。建立三次握手的时候，TCP 报头用到了 `ACK`、`SYN` 这几个标志。



第一次握手，客户端发送连接请求报文，此时 `SYN = 1`、`ACK = 0`，这就是说这是个连接请求，`seq = x`，接着客户端处于 SYN_SEND 状态，等待服务器响应。



第二次握手，服务端收到 SYN = 1 的请求报文，需要返回一个确认报文，`ack = x + 1`、`SYN = 1`、`ACK = 1`、`seq = y`，发送给客户端，自己处于 SYN_RECV 的状态。



第三次握手，客户端收到了报文，将 `ack = y + 1`、`ACK = 1`、`seq = x + 1` 发送给服务端。



这三次握手，说白了，就是来回来去三次请求，每次请求带上一堆 TCP 报文，根据报文是否正确来建立连接。

![三次握手](TCP-的三次握手和四次挥手/三次握手.png)



### 为什么是 3 次握手而不是 2 次 或者 4 次

3 次握手，是为了确认客户端和服务端都能正常的发送和接受信息所需的最少次数。



我们用 SEND 和 ACCEPT 来标志发送信息和接收信息的能力。



第一次握手，客户端并不知道自己是否能正常发送信息，有可能网络不通或者其他原因导致信息丢失。此时它 C_SEND = 0、C_ACCEPT = 0。当服务端接收到数据的时候，那么可以肯定的是服务端能正常接收信息，此时 S_ACCEPT = 1，而S_SEND = 0



第二次握手，服务端发送信息给客户端，同样服务端不知道自己能否正常发送信息，数据能否正确抵达客户端，所以它的 S_SEND = 0。而当客户端收到服务端的响应后，说明自己能正常接收信息，C_ACCEPT = 1，而服务端能返回响应给我，说明第一次的消息发送是正常的，那么也表示客户端发送信息的能力没问题，C_SEND = 1



第三次握手，服务端收到信息，说明第二次握手的时候发送的信息能正常到达客户端，说明服务端的发送信息的能力也没问题。S_SEND = 1



至此，就能确认客户端和服务端都能正常的发送和接收信息。



假设两次握手就 OK 了。如果客户端第一次握手过去，结果卡在了某个地方，没到服务端。超过一定时间，客户端再次重新发送了第一次握手过去，服务端收到了，服务端在发送一个响应正常到达客户端，OK 了，连接建立了。



然后尴尬的事情发生了，之前卡在某个地方的旧的第一次握手终于到达了服务端，然后服务端就直接返回了第二次握手，这个时候服务器开辟了资源准备接收客户端发送数据，但是客户端不会理睬这个第二次握手，因为之前都通信过了。这样就会浪费服务端的资源。



但是如果是三次握手，那个二次握手发回去，客户端发现不对，就会发送个**复位的报文**过去，让服务端撤销开辟的资源。



至于为什么不是 4 次握手，因为 3 次握手就够了，就不需要 4 次或者 5 次浪费资源了。



## TCP 断开连接的 4 次挥手

第一次挥手，客户端发送报文，`FIN = 1`、`seq = u`，此时进入 FIN-WAIT-1 状态



第二次挥手，服务端收到报文，此时进入 CLOSE_WAIT 状态，返回一个报文，`ACK = 1`、`ack = u + 1`、`seq = v`。客户端收到这个报文之后，直接进入 FIN-WAIT-2 状态，此时客户端到服务端的连接就释放了。



第三次挥手，服务端发送连接释放报文，`FIN = 1`、`ack = u + 1`、`seq = w`，服务端进入 LAST_ACK 状态。



第四次挥手，客户端收到连接释放报文之后，发应答报文，`ACK = 1`、`ack = w + 1`、`seq = u + 1`，进入 TIME_WAIT 状态，等待一会儿客户端进入 CLOSED 状态，服务端收到报文之后就进入 CLOSED 状态。

