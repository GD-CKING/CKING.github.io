---
title: MySQL 根据成本优化选择执行计划
date: 2020-07-31 15:57:17
tags: MySQL
categories: MySQL
---

我们在执行单表查询也好，还是多表查询也好，都有多种执行计划可以选择。比如有的表可以全表扫描，有的可以用索引 A，有的用索引 B，那用哪种执行计划呢？



我们先了解 MySQL 里的成本是什么意思。一般跑一个 SQL 语句，一般成本是两块。首先那些数据在磁盘里，是不是要从磁盘里把数据读出来？这个从磁盘读取数据到内存就是 IO 成本，而且 MySQL 里都是一页一页读的，读一页的成本约定为 1.0



接着，就是你拿到数据后，是不是要对数据做一些运算？比如验证它是否符合搜索条件，或者是搞一些排序分组之类的事，这些都是耗费 CPU 资源的，属于 CPU 成本，一般约定读取和检测一条数据是否符合的成本是 0.2



这个所谓的 1.0 和 0.2 是它自定义的一个成本值，代表的意思就是一个数据页 IO 成本是 1.0，一条数据检测的 CPU 成本是 0.2



然后，当你执行 `SELECT * FROM t WHERE x1 = xx AND x2 = xx`。此时你有两个索引，分别是针对 x1 和 x2 建立的。就会看看这个 SQL 可以用到哪几个索引，此时发现 x1 和 x2 的索引都能用到，他们两索引就是 possible keys



接着它会针对这个 SQL 计算一下全表扫描的成本，这个全表扫描就比较坑，因为他是需要先磁盘 IO 把聚簇索引里的叶子节点上的数据页一页一页都读到内存里，这有多少数据页就要耗费多少 IO 成本，接着对内存里的每一条都判断是否符合搜索条件的，这有多少条数据就要耗费多少 CPU 成本



那么如何计算全表扫描的成本呢？可以先通过命令 `show table status like '表名'` 拿到表的统计信息。你在对表进行增删改的时候，MySQL 会给你维护这个表的一些统计信息，比如这里可以看到 `rows` 和 `data_length` 两个信息，不过对于 InnoDB 来说，这个 `rows` 是估计值



`rows` 就是表里的记录数，`data_length` 就是表的聚簇索引的字节数大小，此时用 `data_length` 除以 1024 就是 `kb` 为单位的大小，然后再除以 16kb，就是有多少页，此时知道数据页的数量和 rows 记录数，就可以计算全表扫描的成本了。



IO 成本就是：数据页数量 * 1.0 + 微调值，CPU 成本就是：行记录数 * 0.2 + 微调值。它们两相加，就是一个总的成本值。比如你有数据页 100 个，记录数有 2 万条，此时总成本值就是 100 + 4000 = 4100



## 索引的成本计算

使用索引访问数据的方式，要么你直接根据主键查，那就直接走一个聚簇索引就可以了，如果是普通索引，一般都是两步走，先从二级索引走一波数据，再根据这波数据的主键去聚簇索引回表查询



这个过程的成本计算方式稍微有点特别。首先，在二级索引里根据条件查一波数据的 IO 成本，一般是看你的查询条件涉及到几个范围，比如 name 值在 25 ~ 100,250 ~ 350 两个区间，那么就是两个范围，否则 name = xx 就是一个范围区间



一般一个范围区间就粗暴地认为等同一个数据页，所以此时可能一般根据二级索引查询的时候，这个 IO 成本都会预估地很小，可能就是 1 * 1.0 = 1，或者是 n * 1.0 = n，基本就是个位数这个级别



现在只是通过 IO 读取了二级索引的数据页而已，这仅仅只是二级索引读取的 IO 成本，但是二级索引数据页到内存里后，还要根据搜索条件去拿出来一波数据，拿这波数据的过程就是根据搜索条件在二级索引里搜索的过程。此时就要估算从二级索引里读取符合条件的数据的成本了。这需要估算一下二级索引里会查出多少条数据，这个过程有点复杂，不细节。总之，它会根据一个不是太准确的算法去估算一下根据查询条件可能在二级索引里查出多少条数据来



估算出来之后，比如估算可能会查到 100 条数据，此时从二级索引里查询数据的 CPU 成本就是 100 * 0.2 + 微调值，就是 20 左右而已。接着你拿到 100 条数据之后，就要回表到聚簇索引去查询完整数据，此时先估算回表到聚簇索引的 IO 成本，这里比较粗暴的直接默认 1 条数据就得回表到聚簇索引查询一个数据页，所以 100 条数据就是 100 个数据页的 IO 成本，也就是 100 * 1.0 + 微调值，大致是 100 左右



接着因为在二级索引里搜索到的数据是 100 条，然后通过 IO 成本最多回表到聚簇索引访问 100 个数据页之后，就可以拿到这 100 条数据的完整值了，此时就可以针对这 100 条数据去判断，它们是否符合其他查询条件，这里耗费的 CPU 成本就是 100 * 0.2 + 微调值，就是 20 左右



上面的所有成本都加起来，就是 1 + 20 + 100 + 20 = 141，这就是使用一个索引进行查询的成本的计算方法。假设你直接根据主键去查询，那么也参考上述估算过程就可以了，那就不过时仅仅查询一个聚簇索引而已



上面全表扫描发现成本是 4100 左右，这次根据索引条件查找可能就 141。所以，很多时候，使用索引和全表扫描，它的成本差距是非常大的，所以一般都会针对全表扫描和各个索引的成本，都进行估算，然后比较一下，选择一个成本最低的执行计划



## 多表关联查询如何选择执行计划

其实多表查询的执行计划选择思路，基本跟单表查询的执行计划选择思路是类似的。单表查询的时候，主要就是对这个表的多种访问方式（全表查询，各个索引查询）来根据一定的公式计算出来每种访问方式的成本，接着选择一个成本最低的访问方式，那么就可以确定下来这个表怎么访问了



可能有人会觉得这种成本计算的方式也不是太靠谱，因为里面有些过程怪怪的，不过这也没办法，很难设计出完全公平，完全准确的成本预估算法来。因为要在一个查询执行之前，就可以针对不同的访问方法精准计算它的成本，那是不现实的，最后只是根据一些相对较为粗暴的方法，大致估算一下



接着我们看看多表关联的成本计算访问和执行计划选择方式。看下面的 SQL 语句：



```mysql
SELECT * FROM t1 JOIN t2 ON t1.x1 = t2.x1 WHERE t1.x2 = xxx AND t1.x3 = xxx AND t2.x4 = xxx AND t2.x5 = xxx
```



一般来说，都会先选择一个驱动表。比如 t1 作为驱动表，此时就需要根据 t1.x2 = xxx 和 t1.x3 = xxx 这个条件从表里选择一波符合条件的数据出来，此时就有一个问题，这里用了 t1 的两个字段来筛选数据，可能 x2 和 x3 字段都建了索引了，此时到底选择哪个索引呢？或者干脆就是全表扫描？



此时就会根据上面讲的那套方法来计算针对 t1 表查询的全表扫描和不同索引，选择一个针对 t1 表的最佳访问方式，用最低成本成 t1 表里查出符合条件的数据来，接着就根据这波数据去 t2 表里查数据，按照连接条件 t1.x1 = t2.x1去查，同时要符合 t2.x4 = xxx 和 t2.x5 = xxx 这两个条件



此时一样会根据之前讲解的方法去估算，针对 t2 表的全表扫描以及基于 x4 x5 x1 几个字段不同索引的访问成本，挑选一个成本最低的方法，然后从 t2 表里把数据给查找出来就可以了。这就完成了多表关联



所以，多表关联的成本估算以及执行计划选择方式，跟单表关联基本上是差不多的，只不过多表关联要多查几个表而已





