---
title: 组合模式
date: 2020-08-25 16:47:12
tags: 设计模式
categories: 设计模式
---

树形结构在软件中随处可见，例如操作系统中的目录结构，应用软件的菜单和办公系统中的公司组织结构等。如何运用面向对象的方式来处理这种树形结构是组合模式需要解决的问题。组合模式使用户可以一致性地处理整个树形结构或者树形结构的一部分，也可以一致性处理树形结构中的叶子节点和容器节点（包含子节点的节点）



## 示例

> Sunny 软件公司欲开发一个杀毒软件，该软件既可以对某个文件夹（Folder）杀毒，也可以对某个指定的文件（File）杀毒。该杀毒软件还可以根据各类文件的特点，为不同类型的文件提供不同的杀毒方式。先需要提供杀毒软件的整体设计方案



在 Windows 系统中，包含文件和文件夹两类不同的元素，其中文件夹中可以包含文件，还可以继续包含子文件夹，但是再文件中不能再包含子文件或者子文件夹。在此，可以称**文件夹为容器（Container）**，而不同类型的各种文件是其成员，也称为**叶子**。

![目录树](组合模式/目录树.png)





Sunny 软件公司的开发人员通过分析，决定使用面向对象的方式来实现对文件和文件夹的操作，定义了图像文件类 `ImageFile`、文本文件类 `TextFile` 和文件夹类 `Folder`，代码如下：

```java
/**
 * @Description: 图像文件类
 */
public class ImageFile {

    private String name;

    public ImageFile(String name) {
        this.name = name;
    }

    public void killVirus() {
        // 简化代码，模拟杀毒
        System.out.println("---- 对图像文件「" + name + "」进行杀毒");
    }
}
```



```java
/**
 * @Description: 文本文件类
 */
public class TextFile {

    private String name;

    public TextFile(String name) {
        this.name = name;
    }

    public void killVirus() {
        // 简化代码，模拟杀毒
        System.out.println("---- 对文本文件「" + name + "」进行杀毒");
    }
}
```



```java
/**
 * @Description: 文件夹类
 */
public class Folder {

    private String name;

    /**
     * 定义集合 folderList，用于存储 Folder 类型的成员
     */
    private ArrayList<Folder> folderList = new ArrayList<>();

    /**
     * 定义集合 imageList，用于存储 ImageFile 类型的成员
     */
    private ArrayList<ImageFile> imageList = new ArrayList<>();

    /**
     * 定义集合 textList，用于存储 TextFile 类型的成员
     */
    private ArrayList<TextFile> textList = new ArrayList<>();

    /**
     * 增加新的 Folder 类型的成员
     * @param f
     */
    public void addFolder(Folder f) {
        folderList.add(f);
    }

    /**
     * 增加新的 ImageFile 类型的成员
     * @param image
     */
    public void addImageFile(ImageFile image) {
        imageList.add(image);
    }

    /**
     * 增加新的 TextFile 类型的成员
     * @param text
     */
    public void addTextFile(TextFile text) {
        textList.add(text);
    }

    // 提供 3 个不同的方法 removeFolder()、removeImageFile() 和 removeTextFile() 来删除成员

    // 提供 3 个不同的方法 getChildFolder(int i)、getChildImageFile(int i) 和
    // getChildTextFile(int i) 来获取成员

    public void killVirus() {
        // 模拟杀毒
        System.out.println("**** 对文件夹「" + name + "」进行杀毒");

        // 如果是 Folder 类型的成员，递归调用 Folder 的 killVirus() 方法
        for(Folder obj : folderList) {
            obj.killVirus();
        }

        // 如果是 ImageFile 类型的成员，递归调用 ImageFile 的 killVirus() 方法
        for(ImageFile obj : imageList) {
            obj.killVirus();
        }

        // 如果是 TextFile 类型的成员，递归调用 TextFile 的 killVirus() 方法
        for(TextFile obj : textList) {
            obj.killVirus();
        }
    }
}
```



通过分析，发现该设计方案存在以下问题：

- 文件夹类 `Folder` 的设计和实现都非常复杂，需要定义多个集合存储不同类型的成员，而且需要针对不同的成员提供增加、删除和获取等管理和访问成员的方法，存在大量的冗余代码，系统维护较为困难

- 由于系统没有提供抽象层，客户端代码必须有区别地对待充当容器的文件夹 Folder 和充当叶子的 `ImageFile` 和 `TextFile`，无法统一对它们进行处理

- 系统的灵活性和可扩展性差，如果需要增加新的类型和叶子容器都需要对原有代码进行修改。例如，如果需要在系统中增加一种新类型的视频文件 `VideoFile`，则必须修改 `Folder` 类的源代码，否则无法在文件夹中添加视频文件



为了解决上面的问题，就要用到**组合模式**



## 组合模式概述

对于树形结构，当容器对象的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象）并调用执行，牵一而动百，其中使用了递归调用的机制来对整个结构进行处理。由于容器对象和叶子节点对象在功能上的区别，在使用这些对象的代码中必须有区别地对待容器对象和叶子对象，而实际上大多数情况下希望一致地处理它们，因为对于这些对象的区别对待将会使得程序非常复杂。组合模式就是为了解决此类问题，它可以让叶子对象和容器对象的使用具有一致性



组合模式定义如下：



> **组合模式**：组合多个对象形成树形结构以表示具有「整体 - 部分」关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式是一种对象结构型模式



在组合模式中引入了抽象构件类 `Component`，它是所有容器类和叶子类的公共父类，客户端针对 Component 进行编程。组合模式如图所示：

![组合模式](组合模式/组合模式.png)



由上图可知，组合模式结构图中包含 3 个角色：

- **Component（抽象构件）：**它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法。例如增加子构件，删除、获取子构件等

- **Leaf（叶子构件）：**它在组合模式结构中表示叶子节点对象。叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过捕获异常等方式处理

- **Composite（容器构件）：**它在组合模式中表示容器节点对象。容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法



组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象与抽象构建类之间还建立一个聚合关联关系，在容器中既可以包含叶子，也可以包含容器，以此实现递归，形成一个树形结构



下面通过代码来分析组合模式的各个角色的用途和实现。



对于组合模式中的抽象构件角色，其代码如下：

```java
/**
 * @Description: 抽象文件类：抽象构建
 */
abstract class Component {

    public abstract void add(Component c);

    public abstract void remove(Component c);

    public abstract Component getChild(int i);

    public abstract void operation();
}
```



一般将抽象构件类设计为接口或抽象类，将所有子类共有方法的声明和实现放在抽象构件类中。对于客户端而言，将针对抽象构件编程，而无须关系其具体子类是容器构件还是叶子构件。如果继承抽象构件的是叶子构件，则其典型代码如下：



```java
public class Leaf extends Component {
    @Override
    public void add(Component c) {
        // 异常处理或错误提示
    }

    @Override
    public void remove(Component c) {
        // 异常处理或错误提示
    }

    @Override
    public Component getChild(int i) {
        // 异常处理或错误提示
        return null;
    }

    @Override
    public void operation() {
        // 叶子构件具体业务方法的实现
    }
}
```



作为抽象构件类的子类，在叶子构件中需要实现在抽象构件类中声明的所有方法，包括业务方法以及管理和访问子构件的方法，但是叶子构件不能再包含子构件，因此在叶子构件中实现子构件管理和访问方法时需要提供异常处理和错误提示。当然，这无疑会给叶子构件的实现带来麻烦



如果继承抽象构件的是容器构件，则其典型代码如下：

```java
public class Composite extends Component {

    private List<Component> list = new ArrayList<>();
    @Override
    public void add(Component c) {
        list.add(c);
    }

    @Override
    public void remove(Component c) {
        list.remove(c);
    }

    @Override
    public Component getChild(int i) {
        return list.get(i);
    }

    @Override
    public void operation() {

        // 容器构件具体业务方法的实现
        // 递归调用成员构件的业务方法
        for(Component obj : list) {
            obj.operation();
        }
    }
}
```



在容器构件中实现了在抽象构件中声明的所有方法，既包括业务方法，也包括用于访问和管理成员子构件的方法。需要注意的是，在实现具体业务方法时，由于容器构件充当的是容器角色，包含成员构件，因此它将调用其成员构件的业务方法。



## 完整的解决方案

接下来我们用组合模式来解决示例的那个问题。其基本机构如图所示：

![UML](组合模式/UML.png)



上图中，AbstractFile 充当抽象构件类，Folder 充当容器构件类，ImageFile、TextFile 和 VideoFile 充当叶子构件类，代码如下：



```java
/**
 * @Description: 抽象文件类：抽象构件
 */
abstract class AbstractFile {

    public abstract void add(AbstractFile file);

    public abstract void remove(AbstractFile file);

    public abstract AbstractFile getChild(int i);

    public abstract void killVirus();
}
```



```java
/**
 * @Description: 图像文件类：叶子构件
 */
public class ImageFile extends AbstractFile {

    private String name;

    public ImageFile(String name) {
        this.name = name;
    }

    @Override
    public void add(AbstractFile file) {
        System.out.println("对不起，不支持该方法");
    }

    @Override
    public void remove(AbstractFile file) {
        System.out.println("对不起，不支持该方法");
    }

    @Override
    public AbstractFile getChild(int i) {
        System.out.println("对不起，不支持该方法");
        return null;
    }

    @Override
    public void killVirus() {
        // 模拟杀毒
        System.out.println("---- 对图像文件「" + name + "」进行杀毒");
    }
}
```



```java
/**
 * @Description: 文本文件类：叶子构件
 */
public class TextFile extends AbstractFile {

    private String name;

    public TextFile(String name) {
        this.name = name;
    }

    @Override
    public void add(AbstractFile file) {
        System.out.println("对不起，不支持该方法");
    }

    @Override
    public void remove(AbstractFile file) {
        System.out.println("对不起，不支持该方法");
    }

    @Override
    public AbstractFile getChild(int i) {
        System.out.println("对不起，不支持该方法");
        return null;
    }

    @Override
    public void killVirus() {
        // 模拟杀毒
        System.out.println("---- 对文本文件「" + name + "」进行杀毒");
    }
}
```



```java
/**
 * @Description: 视频文件类：叶子构件
 */
public class VideoFile extends AbstractFile {

    private String name;

    public VideoFile(String name) {
        this.name = name;
    }

    @Override
    public void add(AbstractFile file) {
        System.out.println("对不起，不支持该方法");
    }

    @Override
    public void remove(AbstractFile file) {
        System.out.println("对不起，不支持该方法");
    }

    @Override
    public AbstractFile getChild(int i) {
        System.out.println("对不起，不支持该方法");
        return null;
    }

    @Override
    public void killVirus() {
        // 模拟杀毒
        System.out.println("---- 对视频文件「" + name + "」进行杀毒");
    }
}
```



```java
/**
 * @Description: 文件夹类：容器构件
 */
public class Folder extends AbstractFile {

    /**
     * 定义集合 fileList，用于存储 AbstractFile 类型的成员
     */
    private ArrayList<AbstractFile> fileList = new ArrayList<>();

    private String name;

    public Folder(String name) {
        this.name = name;
    }

    @Override
    public void add(AbstractFile file) {
        fileList.add(file);
    }

    @Override
    public void remove(AbstractFile file) {
        fileList.remove(file);
    }

    @Override
    public AbstractFile getChild(int i) {
        return fileList.get(i);
    }

    @Override
    public void killVirus() {
        // 模拟杀毒
        System.out.println("**** 对文件夹「" + name + "」进行杀毒");

        // 递归调用成员构件的 killVirus() 方法
        for(AbstractFile obj : fileList) {
            obj.killVirus();
        }
    }
}
```



```java
public class Client {

    public static void main(String[] args) {

        // 针对抽象构件编程
        AbstractFile file1, file2, file3, file4, file5, folder1, folder2, folder3, folder4;

        folder1 = new Folder("Sunny 的资料");
        folder2 = new Folder("图像文件");
        folder3 = new Folder("文本文件");
        folder4 = new Folder("视频文件");

        file1 = new ImageFile("小龙女.jpg");
        file2 = new ImageFile("张无忌.gif");
        file3 = new TextFile("九阴真经.txt");
        file4 = new TextFile("葵花宝典.doc");
        file5 = new VideoFile("笑傲江湖.rmvb");

        folder2.add(file1);
        folder2.add(file2);
        folder3.add(file3);
        folder3.add(file4);
        folder4.add(file5);

        folder1.add(folder2);
        folder1.add(folder3);
        folder1.add(folder4);

        folder1.killVirus();
    }
}
```



由于在实例中使用了组合模式，在抽象构件类中声明了所有方法，包括用于管理和访问子构件的方法，因此在 `ImageFile` 等叶子构件类中实现这些方法时必须进行相应的异常处理或错误提示。在容器构件类 `Folder` 的 killVirus() 方法中递归调用其成员对象的 killVirus() 方法，从而实现对整个树形结构的遍历



如果需要更换操作节点，例如只需对文件夹「文本文件」进行杀毒，客户端代码只需修改一行即可：将代码 `folder1.killVirus()` 改为 `folder3.killVirus()`



## 透明组合模式与安全组合模式 

引入组合模式，Sunny 公司设计的杀毒软件具有良好的可扩展性，在增加新的文件类型时，无须修改现有类库代码，只需增加一个新的文件夹作为 `AbstractFile` 类的子类即可。但是由于在 AbstractFile 中声明了大量用于管理和访问成员构件的方法，例如 add()、remove() 等方法，就不得不在新增的文件类中实现这些方法，提供对应的错误提示和异常处理。为了简化代码，有以下两种结局方案



**解决方案 1：**将叶子构件的 add()、remove() 等方法的实现代码移至 AbstractFile 类中，由 AbstractFile 提供统一的默认实现，代码如下：

```java
abstract class AbstractFile {

    public void add(AbstractFile file) {
        System.out.println("对不起，不支持该方法");
    }

    public void remove(AbstractFile file) {
        System.out.println("对不起，不支持该方法");
    }

    public AbstractFile getChild(int i) {
        System.out.println("对不起，不支持该方法");
        return null;
    }

    public abstract void killVirus();
}
```



如果客户端代码针对抽象类 `AbstractFile` 编程，在调用文件对象的这些方法时将出现错误提示。如果不希望出现任何错误提示，可以在客户端定义文件对象时不使用抽象层，而直接使用具体叶子构件本身。代码如下：

```java
public class Client {

	public static void main(String args[]) {
		// 不能透明处理叶子构件
		ImageFile file1, file2;
		TextFile file3, file4;
		VideoFile file5;
		
		AbstractFile folder1, folder2, folder3, folder4;
		// 其他代码省略
	}
}
```



这样就产生了一种不透明的使用方式，即在客户端不能全部针对抽象构件类编程，需要使用具体叶子构件类型来定义叶子对象



解决方案 2：在抽象构件 AbstractFile 中不声明任何用于访问和管理成员构件的方法，代码如下：

```java
abstract class AbstractFile {

    public abstract void killVirus();
}
```



此时，由于在 AbstractFile 中没有声明 add()、remove() 等访问和管理成员的方法，其叶子构件子类无须提供实现；而且无论客户端如何定义叶子构件对象都无法调用到这些方法，不需要做任何错误和异常处理，容器构件再根据需要增加访问和管理成员的方法。但这时候也存在一个问题：客户单不得不使用容器类本身来声明容器构件对象，否则无法访问其中新增的 add()、remove() 等方法。如果客户端一致性地对待叶子和容器，将会导致容器构件的新增对客户端的不可见，客户端代码对于容器构件无法再使用抽象构件来定义。代码如下：

```java
public class Client {
	
	public static void main(String args[]) {
		
		AbstractFile file1, file2, file3, file4, file5;
		// 不能透明处理容器构件
		Folder folder1, folder2, folder3, folder4;
		
		// 其他代码省略
	}
}
```



使用组合模式时，根据抽象构件类的定义，可将组合模式分为透明组合模式和安全组合模式两种类型。



### 透明组合模式

透明组合模式中，抽象构件类 `Component` 中声明了所有用于管理成员对象的方法，包括 add()、remove() 和 getChild() 等方法，这样做的好处是确保所有的构件类都有相同的接口。在客户端看来，叶子对象与容器对象所提供的方法时一致的，客户端可以相同地对待所有的对象。透明组合模式也是组合模式的标准形式，虽然上面的解决方案 1 在客户端可以有不透明的实现方式，但是由于在抽象构件中包含 add()、remove() 等方法，因此它还是透明组合模式

![透明组合模式](组合模式/透明组合模式.png)



透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法时没有意义的。这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）



### 安全组合模式

安全组合模式中，在抽象构件 `Component` 中没有声明任何用于管理成员对象的方法，而是在 `Composite` 类中声明并实现这些方法。这种做法是安全的，因为根本不向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法，这就是解决方案 2 中所采用的实现方式。如图所示：

![安全组合模式](组合模式/安全组合模式.png)



安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象对象编程，必须与区别地对待叶子构件和容器构件。在实际应用中，安全组合模式的使用频率也非常高，在 Java AWT 中使用的组合模式就是安全组合模式



## 组合模式总结

组合模式使用面向对象的思想来实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型组合模式。除此之外，在 XML 解析，组织结构树处理、文件系统设计等领域，组合模式都得到了广泛应用



### 主要优点

- 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制

- 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码

- 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合开闭原则

- 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单



### 主要缺点

组合模式的主要缺点是：在增加新构件时很难对容器中的构件类进行限制。有时候希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个过程较为复杂



### 使用场景

以下情况下可以考虑使用组合模式：

- 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致性地对待它们

- 在一个使用面向对象语言开发的系统中需要处理一个树形结构

- 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型



## 参考资料

《设计模式的艺术——软件开发人员内功修炼之道》 – 刘伟