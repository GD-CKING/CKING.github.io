---
title: JVM之jstat案例分析-Young GC
date: 2020-01-02 11:28:39
tags: JVM
categories: JVM
---

## 百万级商机的BI系统

​		有这么一个场景，有一个服务于百万级商机的BI系统。所谓BI系统，简单来说，就是一个平台有数十万甚至上百万的商家在你的平台上做生意，会使用你的这个平台系统，此时会产生大量的数据。然后基于这些数据我们需要为商家提供一些数据报表，比如：每个商家每天有多少访客？有多少交易？付费转化率是多少？当然实际情况会比这个更复杂，这里只是说个概念。

​		此时就需要一套BI系统，所谓BI，全称是`Business Intelligence`，就是“商业智能”。就是把一些商家平时日常经营的数据收集起来进行分析，然后把各种数据报表展示给商家的一套系统。而所谓的商业智能，指的就是给你看一些数据报表，然后让你平时更好地了解自己的经营情况，然后让老板“智能”地去调整经营策略，提升业绩。

​		所以类似这样的一个BI系统，大致的运行逻辑如下所示：

- 首先，从我们提供给商家日常使用的一个平台上会采集出来很多商家日常经营的数据；

- 接着可以对这些经营数据依托各种大数据计算平台，比如Hadoop、Spark、Flink等技术进行海量数据的计算，计算出各种各样的数据报表；

- 然后我们需要将计算好的各种数据分析报表都放入一些存储中，比如MySQL、Elasticsearch、HBase都可以存放类似的数据；

- 最后，就是基于MySQL、HBase、Elasticsearch中存储的数据报表，基于Java开发出来一个BI系统，通过这个系统把各种存储好的数据暴露给前端，允许前端基于各种条件对存储的数据进行复杂的筛选和分析。

​		这个流程如图所示：

![BI](JVM之jstat案例分析-Young-GC/BI.png)

### 刚开始上线时的架构部署

​		我们这里重点作为案例分析的就是上述场景中的“BI系统”，其他环节都跟大数据相关的技术有关联的，暂时先不care。

​		刚开始的时候BI系统使用的商家是不多的，因为即使在一个庞大的互联网大厂里，虽然大厂本身积累了大量商家，但是要针对他们上线一个付费产品，刚开始未必所有人都买账，所以一开始系统上线就少数商家在使用，比如就几千个商家。

​		刚开始系统部署非常简单，就是用几台机器来部署上述的BI系统，机器都是普通的4核8G配置。在这个配置下，一般来说给堆内存中的新生代分配的内存都在1.5G左右，Eden区大概也就1G左右的空间，如图：

![内存分配](JVM之jstat案例分析-Young-GC/内存分配.png)

### 技术痛点：实时自动刷新报表 + 大数据量报表

​		刚开始，在少数商家的量级下，这个系统是没多大问题，运行的非常良好。但是问题恰恰就出在突然使用系统的商家数量开始暴涨的时候，突然使用系统的商家开始越来越多，例如，当商家的数量级达到几万的时候。此时要给大家说明一个此类BI系统的特点，就是在BI系统中有一种数据报表，它是支持前端页面有一个JS脚本，自动每隔几秒钟就发送请求到后台刷新一下数据的，这种报表称之为“实时数据报表”

​		那么大家设想一下，假设仅仅就几万商家作为你的系统用户，很可能同一时间打开那个实时报表的商家就有几千个，然后每个商家打开实时报表后，前端页面都会每隔几秒钟发送请求到后台加载最新数据，基本上会出现BI系统部署的每台机器每秒的请求会达到几百个，这里我们假设就是每秒500个请求吧。然后每个请求都会加载出来一张报表需要的大量数据，因为BI系统可能还需要针对那些数据进行内存中的现场计算加工一下，才能返回给前端页面展示，根据我们之前的测算，每个请求大概需要加载出来100KB的数据进行计算，因此每秒500个请求，就需要记载出来50MB的数据到内存中进行计算，如图：

![整个流程](JVM之jstat案例分析-Young-GC/整个流程.png)

### 没什么大影响的频繁Young GC

​		在上述系统运行模型下，基本上每秒会加载50MB的数据到Eden区中，只要区区20s，就会迅速填满Eden区，然后触发一次Young GC对新生代进行垃圾回收。当然1G左右的Eden进行Young GC速度相对是比较快的，可能也就几十ms的时间就可以搞定了。所以其实对系统性能影响并不大，而且上述BI系统场景下，基本上每次Young GC后存活对象可能就几十MB，甚至是几MB。

​		所以如果仅仅只是这样的话，那么大家可能会看到如下场景，BI系统运行20s过后，就会突然卡顿个10ms，但是对终端用户和系统性能几乎是没有影响的。

## 模拟频繁Young GC场景

​		接着我们会用一段程序来模拟上述BI系统那种频繁Young GC的一个场景，此时JVM参数如下所示：

```
-XX:NewSize=104857600 -XX:MaxNewSize=104857600 -XX:InitialHeapSize=209715200 -XX:MaxHeapSize=209715200 -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=3145728 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log
```

​		大家只要注意一下上述我们把堆内存设置为了200MB，把年轻代设置为了100MB，然后Eden区是80MB，每块Survivor区是10MB，老年代也是100MB。我们把案例中的内存大小适当缩小了一些，这样方便在本地电脑进行试验。

### 示例程序

```java
public class Demo1 {

    public static void main(String[] args) throws Exception {
        Thread.sleep(30000);
        while (true) {
            loadData();
        }
    }

    private static void loadData() throws Exception {
        byte[] data = null;
        for(int i = 0; i < 50; i++) {
            data = new byte[100 * 1024];
        }
        data = null;
        Thread.sleep(1000);
    }
}
```

​		针对这段示例程序给大家做一点说明。首先看第一行代码：`Thread.sleep(30000);`。这里刚开始休眠30s，是为了启动程序后，让我们找到这个程序的PID，也就是进行ID，然后再执行`jstat`命令来观察运行时的JVM的状态。

​		接着看loadData()方法内的代码，它会循环50次，模拟每秒50个请求，然后互每次请求都会分配一个100KB的数组，模拟每次请求会从存储中加载100KB的数据，接着会休眠1秒钟，模拟这一切都是发生在1秒内的。其实这些对象都是短生存周期的对象，所以方法运行结束直接对象都是垃圾，随时可以回收的。然后在main()方法里有一个while(true)循环，模拟系统按照每秒钟50个请求，每个请求加载100KB数据的方式不停地运行，除非我们手动终止程序，否则永不停歇。

### 通过jstat观察程序的运行状态

​		接着我们使用预定的JVM参数启动程序，此时程序会先进入一个30秒的休眠状态，此时尽快执行`JPS`命令，查看一下我们启动程序的进程ID，如下图：

![jps](JVM之jstat案例分析-Young-GC/jps.png)

​		此时会发现我们运行的Demo1这个程序的JVM进程ID是51464，然后尽快执行下述jstat命令：`jstat -gc 51464 1000 1000`。它的意思是针对51464这个进程统计JVM运行状态，同时每隔1秒钟打印一次统计信息，连续打印1000次。然后我们就让jstat开始统计运行，每隔一秒它都会打印一行新的统计信息，过了几十秒后可以看到如下图所示的统计信息：

![统计信息](JVM之jstat案例分析-Young-GC/统计信息.png)

​		接着我们一点点来分析这个图。首先我们先看如下图所示的一段信息：

![EU](JVM之jstat案例分析-Young-GC/EU.png)

​		这个EU，就是之前我们所说的Eden区被使用的容量，可以发现它刚开始是3MB左右的内存使用量。接着从我们程序开始运行，会发现每秒钟都会有对象增长，从3MB左右到7MB左右，接着是12MB，17MB，22MB，每秒都会新增5MB左右的对象。这个跟我们写的代码是完全吻合的，我们就是每秒钟会增加5MB左右的对象。然后当Eden区使用量达到70多MB的时候，再要分配5MB的对象就失败了，此时就会触发一次Young GC，然后大家继续看下图：

![Young GC](JVM之jstat案例分析-Young-GC/Young_GC.png)

​		注意看上面红圈里的内容，大家会发现，Eden区的使用量从70多MB降低为1MB多，这就是因为一次Young GC直接回收掉了大部分对象。所以我们现在就知道了，针对这个代码示例，可以清晰地从jstat中看出来，对象增速大致为5MB每秒，大致在十几秒左右会触发一次Young GC。这就是Young GC的触发频率，以及每次Young GC的耗时。接着看下图：

![YGC](JVM之jstat案例分析-Young-GC/YGC.png)

​		上图清晰告诉你，一次Young GC回收70多MB对象，大概就1毫秒，所以Young GC其实是很快的，即使回收800MB的对象，也就10毫秒那样。所以如果是线上系统，Eden区800MB的话，每秒新增对象50MB，十多秒一次Young GC，也就10毫秒左右，系统卡顿10毫秒，几乎没什么大影响。所以我们继续推论，在这个示例中，80MB的Eden区，每秒新增对象5MB，大概十多秒触发一次Young GC，每次Young GC耗时在1毫秒左右。

​		那么每次Young GC过后存活的对象呢？简单看上图，S1U就是Survivor中被使用的内存，之前一直都是0，在一次Young GC过后变成了675KB，所以一次Young GC后也就存活675KB的对象而已，轻松放入10MB的Survivor中。

​		而且大家注意上上图中的OU，那是老年代被使用的内存量，在Young GC前后都是0。说明这个系统运行良好，Young GC都不会导致对象进入老年代，这就几乎不需要什么优化了，因为几乎可以默认老年代对象增速为0，Full GC发生频率趋向于0，对系统无影响。

​		所以回顾一下，通过这个示例程序的运行，是不是可以通过jstat分析出来以下信息：

- 新生代对象增长的速率

- Young GC的触发频率

- Young GC的耗时

- 每次Young GC后有多少对象是存活下来的

- 每次Young GC过后有多少对象进入了老年代

- 老年代对象的增长速率

- Full GC的触发频率

- Full GC的耗时