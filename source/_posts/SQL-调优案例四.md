---
title: SQL 调优案例四
date: 2020-10-20 10:46:51
tags: MySQL
categories: MySQL
---

这个案例的背景是，有人删除了千万级的数据，结果导致了频繁的慢查询，接下来说一下这个案例排查、定位以及解决的一个过程。当时是从线上收到大量的慢查询告警开始的，当我们收到大量的慢查询告警之后，就去检查慢查询的 SQL，结果不是什么特别的 SQL，这些 SQL 语句主要都是针对一个表的，比较简单，看起来不应该会慢查询



那么有没有可能，慢查询不是 SQL 的问题，而是 MySQL 生产服务器的问题？实际上个别特殊情况下，MySQL 出现慢查询并不是 SQL 语句的问题，而是它自己生产服务器的负责太高了，导致 SQL 语句执行很慢



例如，假设现在 MySQL 服务器的磁盘 IO 负载特别高，也就是每秒执行大量的高负载的随机 IO，但是磁盘本身每秒能执行的随机 IO 是有限的。结果，就导致你正常的 SQL 语句去磁盘上执行的时候，如果要跑一些随机 IO，你的磁盘太忙了，顾不上你，导致你本来很快的 SQL，要等很久才能执行完毕，这就可能导致正常的 SQL 语句也会变成慢查询



同理，还有网络。如果网络负载很高，就可能导致你一个 SQL 语句要发送到 MySQL 上去，光是等待获取一个跟 MySQL 的连接，都要等很久；或者 MySQL 自己网络负载太高，带宽被打满了，你一个 SQL 也许执行很快，但是它查出来的数据返回给你，网络都送不出去，此时也会变成慢查询



还有 CPU 负载，如果 CPU 负载过高，也会导致 CPU 过于频繁去执行别的任务，没时间执行你这个 SQL 语句，此时也有可能导致你的 SQL 语句出现问题



所以慢查询本身不一定是 SQL 导致的，如果你觉得 SQL 不应该慢查询，但那个时间段跑这个 SQL 就是慢，**那么你应该排查一下当时 MySQL 服务器的负载，尤其看看磁盘、网络以及 CPU 的负载，是否正常**，如果那个时间段 MySQL 生产服务器的磁盘、网络或者 CPU 负载特别高，那么可能是服务器负载导致的问题



例如，当某个离线作业瞬间把大批量数据往 MySQL 里灌入的时候，它一瞬间服务器磁盘、网络以及 CPU 的负载会超高。此时你一个正常的 SQL 执行下去，短时间内一定会慢查询。针对此类问题，优化手段更多是控制你导致 MySQL 负载过高的那些行为，比如灌入大量数据，最好在凌晨低峰期灌入，别影响线上系统运行



但当时我们看了 MySQL 服务器的磁盘、网络以及 CPU 负载，一切正常，似乎不是这个问题导致的



## profiling

排查了 SQL 执行计划和 MySQL 服务器负载，都没有问题。此时就要用上一个 SQL 调优的利器了，也就是 `profiling` 工具，这个工具可以对 SQL 语句的执行耗时进行非常深入和细致的分析，使用这个工具的过程，大致如下所示：



首先要打开这个 profiling，要使用 `set profiling = 1` 这个命令，接着 MySQL 就会自动记录查询语句的 profiling 信息了



此时如果执行 `show profiles` 命令，就会给你列出各种查询语句的 profiling 信息，这个很关键的一点，就是它会记录下来每个查询语句的 query id，所以你要针对你需要分析的 query 找到对应的 query id，当时就是针对慢查询的那个 SQL 语句找到了 query id



然后就可以针对单个查询语句，看下它的 profiling 具体信息，使用 `show profile cpu, block io for query xx`，这里的 xx 是数字，此时就可以看到具体的 profile 信息了。它这里会给你展示出来 SQL 语句执行时的各种耗时，比如磁盘 IO 的耗时，CPU 等待耗时，发送数据耗时，拷贝数据到临时表的耗时等等。



这里我们检查了这个 SQL 语句的 profiling 信息，发现了一个问题，它的 `Sending Data` 的耗时是最高的，几乎使用了 1s 的时间，占据了 SQL 执行耗时的 99%，这就坑爹了。因为其它环节耗时低是可以理解的，毕竟这种 SQL 执行速度真的很快，基本就是 10ms 级别的，结果跑成了 1s，那肯定 Sending Data 是罪魁祸首了



`Sending Data` 干嘛的？MySQL 官方释义是：为一个 SELECT 语句读取和处理数据行，同时发送数据给客户端的过程。简答说就是为你的 SELECT 语句把数据读出来，同时发送给客户端



可是这个过程为什么会这么慢？profiling 确实给我们提供了线索，但是似乎还没法解决问题



接着我们又用了一个命令：`show engine innodb status`，看一下 InnoDB 存储引擎的一些状态，此时发现了一个奇怪的指标，就是 `history list length` 这个指标，它的值特别高，达到了上万这个级别



如果调优的时候发现了类似的情况，不知道一个指标什么意思，可以 Google 一下，这里直接告诉大家



之前我们讲过 MVCC 机制，这个 MVCC 和隔离级别的实现原理，跟一个 Read View 机制是有关系的，同时还有一个至关重要的机制，就是数据的 undo 多版本快照链条。你必须对一个数据有一个多版本快照链条，才能实现 MVCC 各种隔离级别



所有当你有大量事务执行的时候，就会构建这种 undo 多版本快照链条，此时 `history list length` 的值就会很高。然后在事务提交之后，会有一个多版本快照链条的自动 `purge` 清理机制，只要有清理，这个值就会降低



一般来说，这个值是不应该过于高的。但是这里的 `history list length` 的值过高，大量的 undo 多版本链条数据没别清理，推测可能就是有的事务长时间运行，所以他的多版本快照不能被 purge 清理，进行导致了这个 history list length 的值过高



现在我们就 GET 到了两个线索。可以肯定的是，经过两个线索的推测，在大量简单 SQL 语句变成慢查询的时候，SQL 是因为 Sending Data 环节异常耗时过高，同时此时出现了一些长事务长时间运行，大量地频繁更新数据，导致有大量的 undo 多版本快照链条，还无法 purge 清理



那这两个线索之间的关系是什么呢？我们接着排查



## 真相大白

经过排查，发现有大量的更新语句在活跃，而且有那种长期活跃的超长事务一直在跑没有结束，结果一问系统负责人，发现他在后台跑了一个定时任务，定时清理数据，结果清理的时候一下子清理了上千万的数据



这个清理是怎么做的呢？他开了一个事务，然后在一个事务里删除上千万数据，导致这个数据一直在运行，所以才发生上面说到的现象



然后呢，这种长事务的运行会导致一个问题，那就是删除的时候仅仅只是对数据追加了一个删除标记，事实上并没有彻底删除掉。此时你如果跟长事务同时运行的其他事务在查询，它在查询的时候是可能把那上千万被标记为删除的数据都扫描一遍的。因为没扫描到一批数据，都发现标记为删除了，接着就会再继续往下扫描，所以才导致一些查询语句会那么慢



那么，为什么你启动一个事务，在事务里查询，凭什么就要去扫描之前那个长事务标记为删除状态的上千万垃圾数据呢？按说那些数据都被删除了，跟你没关系了，你可以不用去扫描他们啊



这个问题的关键点在于，那个删除千万级数据的事务是个长事务。即，当你启动新事物的时候，那个删除千万级数据的长事务一直在运行，是活跃的。



我们之前讲解 MVCC 的时候说过，当你启动一个新事务查询的时候，会生成一个 ReadView，里面包含了当前活跃事务的最大id，最下 id 和事务 id 集合，然偶胡它有一个判定规则，具体判定规则可以去回顾之前的文章



总之就是，你的新事务查询的时候，会根据 ReadView 去判断哪些数据是你可见的，以及你可见的数据版本是哪个版本，因为一个数据有一个版本链条，有时候你可能可见的仅仅是这个数据的一个历史版本而已



所以正是以为这个长事务一直在运行还在删除大量的数据，而且这些数据仅仅是标记为删除，实际还没删除，所以此时你新开事务是会读到所有被标记为删除的数据的，就会出现千万级的数据扫描，才会造成慢查询



针对这个问题，要知道的一点是，永远不要再业务高峰期去运行那种删除大量数据的语句，因为这可能导致一些正常的 SQL 都变慢查询，因为那些 SQL 也行会不断扫描你标记为删除的大量数据，好不容易扫描到一批数据，结果发现是标记为删除的，于是继续扫描下去，导致了慢查询



因此当时的解决方案也很简答，直接 kill 那个正在删除千万级数据的长事务，所有 SQL 很快恢复正常。从此以后，对于大量数据清理全部放在凌晨去执行，那个时候就没什么人使用系统了，所以查询也少



