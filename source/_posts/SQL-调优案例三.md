---
title: SQL 调优案例三
date: 2020-09-25 15:22:23
tags: MySQL
categories: MySQL
---

## 案例背景

一个商品评论系统的数据量非常大，拥有十亿量级的评论数据，所以对这个评论数据库，做了分库分表，基本上分完库和表后，单表的评论数据在百万级别。每一个商品的所有评论都是放在一个库的一张表里的，这样可以确保你作为用户在分页查询一个商品的评论时，一般都是直接从一个库的一张表里执行分页查询语句就可以了



在电商网站里，有一些热门的商品的评论可能多达几十万条。然后有些用户就喜欢不停的对某个热门商品的评论不断的进行分页，一页一页翻，有时候还会用上分页跳转功能，就是直接输入自己要跳到第几页去。所以这个时候，就会涉及到一个问题，**针对一个商品几十万评论的深分页问题**。



先来看看一个经过我们简化后的对评论表进行分页查询的 SQL 语句:

```mysql
SELECT * FROM comments WHERE product_id = 'xx' AND is_good_comment = '1' ORDER BY id DESC LIMIT 100000, 20
```



它的意思是，比如用户选择了查看某个商品的评论，因此必须限定 product_id，同时还选了只看好评，所以 is_good_comment 也要限定一下。接着他要看第 5001 页评论，那么此时 limit 的 offset 就会是(5001 - 1) * 20，其中 20 就是每一页的数量，此时起始 offset 就是 100000，所以 limit 后 100000, 20



对这个评论表呢，最核心的索引就是 index_product_id，所以对上述 SQL 语句，正常情况下，肯定是会走这个索引的，即，会通过 index_product_id 索引，根据 product_id = 'xx' 这个条件从表里先删选出来这个表里指定商品的评论数据。



接着，按照 is_good_comment='1' 条件，筛选出这个商品评论数据里的所有好评。但是，index_product_id 的索引数据里，并没有 is_good_comment 字段的值，所以只能进行回表。即，对这个商品的每一条评论，都要进行一次回表操作，回到聚簇索引里，根据 id 找到那条数据，取出 is_good_comment 字段的值，接着对 is_good_comment = '1' 条件做一个比对，筛选符合条件的数据。



假设这个商品的评论有几十万条，那岂不是要做几十万次回表操作？虽然每次回表都是根据 id 在聚簇索引里快速查找，但也是架不住每条数据都回表啊



接着对于筛选完毕的符合 WHERE product_id = 'xx' AND is_good_comment = '1' 条件的数据，假设有十多万条，就这就是按照 id 做一个倒序排序，此时还得基于临时磁盘文件进行倒序排序，又要耗时很久。排序完毕，就得基于  limit 100000， 20 获取第 5001 页的 20 条数据，最后返回



这个过程，因为有几十万次回表查询，还有十多万条数据的磁盘文件，所以这条 SQL 基本要跑个 1 秒 ~ 2 秒



## SQL 优化

如何优化？其实优化思路，跟我们说的第二个案例反过来了。第二个案例是基于商品品类去查商品表，是尽量避免对聚簇索引进行扫描，因为有可能找不到你指定的品类下的商品，出现聚簇索引全表扫描的问题。所以在第二个案例里，反而就是选择强制使用一个联合索引，快速定位到数据，这个过程中因为不需要回表，所以效率还是很高的



接着直接根据 id 临时磁盘文件排序后找到 20 条分页数据，再回表查询 20 次，找到 20 条商品的完整数据。因此当时对第二个案例而言，因为不涉及到大量回表的问题，所以这么做基本是合适的，性能通常在 1s 以内



但是我们这个案例里，就不是这么回事了，因为 where product_id = 'xx' and is_good_comment = '1' 这两个条件，不是一个联合索引，所以会出现大量的回表操作，这个耗时是极高的。因此对于这个案例，我们通常会采用如下方式改造分页查询语句：

```mysql
SELECT * FROM comments a, (SELECT id FROM comments WHERE product_id = 'xx' AND is_good_comment = '1' ORDER BY id DESC LIMIT 100000, 20) b WHERE a.id = b.id  
```



上面那个 SQL 语句的执行计划就会彻底改变它的执行方式。它通常会先执行括号里的子查询，子查询反而会使用 PRIMARY 聚簇索引，按照聚簇索引的 id 值的倒序方向进行排序，扫描过程中就把符合 WHERE product_id = 'xx' AND is_good_comment = '1' 条件的数据筛选出来。



比如这里就筛选出了十万多条的数据，并不需要把符合条件的数据都找到，因为 limit 后跟的是 100000,, 20，理论上只要有 100000 + 20 条符合条件的数据，而且是按照 id 有序的，此时就可以执行根据 limit 100000, 20 提取到 5001 页的这 20 条数据



接着你会看到执行计划里会针对这个子查询的结果集，一个临时表，`<derived2>` 进行全表扫描，拿到 20 条数据，接着对 20 条数据遍历，每一条数据都按照 id 去聚簇索引里查找一下完整数据，就可以了



所以针对我们的这个场景，反而是优化成这种方式来执行分页，它会更加合适一些，它只有一个扫描聚簇索引筛选符合你分页所有数据的成本，你的分页深度越深，扫描数据越多，分页深度越浅，扫描数据就越少，然后在做一页 20 条数据的 20 次回表查询就可以了



这还还要提一下，其实 SQL 调优实际上是没有银弹的。比如第二个案例来说，按顺序扫描聚簇索引方案可能会因为找不到数据导致亿级数据量的全表扫描，所以对第二个案例而言，必须得根据二级索引去查找。但是对于我们这个案例而言，因为提前做了分库分表，评论表单表数据在一百万左右，所以，即使一个商品没有评论，有全表扫描，也绝不会像扫描上亿数据表那么慢



其次，如果你根据 product_id 的二级索引查找，反而可能出现几十万次回表查询，所以二级索引查找方式反而不适合。 